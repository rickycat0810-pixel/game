<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>透視射擊遊戲</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
      background: black;
      height: 100%;
    }
    canvas { 
      display: block; 
      margin: auto; 
      background: black; 
      touch-action: none;
    }
    #restartBtn, #toggleGridBtn {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 18px;
      background: #444;
      color: white;
      border: none;
      cursor: pointer;
    }
    #toggleGridBtn { display: none; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<button id="restartBtn">開始遊戲</button>
<button id="toggleGridBtn">顯示格線</button>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const restartBtn = document.getElementById("restartBtn");
const toggleGridBtn = document.getElementById("toggleGridBtn");

let facingRight= 1;
let basePlayerW, basePlayerH;
let player, enemy, bullets, enemyBullets, vanishPoint, bottomBoundaryY, playerHP, enemyHP, gameOver;
let lastPlayerShot = 0, lastEnemyShot = 0, lastEnemyDodge = 0;
const shotCooldown = 500, dodgeCooldown = 200, maxHP = 5;

const RICO_MATH = 
{
 get ViewDeep() { let RICO_BUF = bottomBoundaryY - vanishPoint.y; if(RICO_BUF < 1) RICO_BUF = 1; return RICO_BUF; }


};



// 載入圖片
const playerImg = new Image();
playerImg.src = "玩家.png";
const enemyImg = new Image();
enemyImg.src = "敵人.png";
const bgImg = new Image();
bgImg.src = "背景.png";
const failImg = new Image();
failImg.src = "fail.png";


// 載入BGM
const bgm = new Audio("bgm.mp3");
bgm.loop = true;
bgm.volume = 0.5;

//載入音效
const shootSound = new Audio("發射.mp3");
const hitSound = new Audio("被擊中.mp3");
const winSound = new Audio("win.mp3");
const failSound = new Audio("fail.mp3");

// 控制格線顯示
let showGrid = false;
toggleGridBtn.addEventListener("click", () => {
  showGrid = !showGrid;
  toggleGridBtn.textContent = showGrid ? "隱藏格線" : "顯示格線";
});

// 預先計算格線座標
const gridLines = [];
function initGrid(){
  gridLines.length = 0;
  for(let i=0;i<30;i++){
    let x = (canvas.width/30)*i;
    gridLines.push({x});
  }
}

// 自適應畫面
function resizeCanvas() {
  let oldW = canvas.width; 
  let oldH = canvas.height;

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight * 0.9;

  let NewSizeWScale = canvas.width / oldW;
  let NewSizeHScale = canvas.height / oldH;

  // 玩家大小固定為寬度的 1/9
  basePlayerW = canvas.width /9;
  basePlayerH = basePlayerW * (50/35);

  // 重新計算消失點與底邊界
  vanishPoint = { x: canvas.width/2, y: canvas.height*(31/48) };
  bottomBoundaryY = canvas.height;

  // 重新生成格線
  initGrid();

  // 玩家依比例調整
  if(player){
	player.x = player.x * NewSizeWScale; 
	player.y = player.y * NewSizeHScale;
  }
  
  // 敵人依比例調整
  if(enemy){
	enemy.x = enemy.x * NewSizeWScale; 
	enemy.y = enemy.y * NewSizeHScale; 
	let enemyCalc = getEnemyScale(enemy.y); 
	enemy.scale = enemyCalc.scale;	
  }

  // 子彈依比例調整 
  bullets.forEach(b => { 
    //位置
	b.startX = b.startX * NewSizeWScale; 
	b.startY = b.startY * NewSizeHScale; 
	b.x = b.x * NewSizeWScale 
	b.y = b.y * NewSizeHScale; 
	
	//大小 (使用寬度比例)
	b.size = b.size * NewSizeWScale;
	
	//速度 (使用寬度比例)
	b.speed = b.speed * NewSizeWScale;
  }); 
  
  // 敵人子彈比例調整
  enemyBullets.forEach(b => { 
    b.startX = b.startX * NewSizeWScale; 
	b.startY = b.startY * NewSizeHScale; 
	b.x = b.x * NewSizeWScale 
	b.y = b.y * NewSizeHScale; 
	
	//大小 (使用寬度比例)
	b.size = b.size * NewSizeWScale;
	
	//速度 (使用寬度比例)
	b.speed = b.speed * NewSizeWScale;
  });

}
window.addEventListener("resize", resizeCanvas);
window.addEventListener("orientationchange", resizeCanvas);

// 透視公式
function getPerspectiveX(y, baseX){
  return vanishPoint.x + (baseX - vanishPoint.x) * ((y - vanishPoint.y) / RICO_MATH.ViewDeep);
}
function getEnemyScale(y) {
  let eLeftX = getPerspectiveX(y, 0);
  let eRightX = getPerspectiveX(y, canvas.width);
  let enemyWidth = eRightX - eLeftX;

  let pLeftX = getPerspectiveX(player.y, 0);
  let pRightX = getPerspectiveX(player.y, canvas.width);
  let playerWidth = pRightX - pLeftX;

  return { scale: (enemyWidth / playerWidth), width: enemyWidth };
}
function getBulletScale(y) {
  let bLeftX = getPerspectiveX(y, 0);
  let bRightX = getPerspectiveX(y, canvas.width);
  let bulletWidth = bRightX - bLeftX;

  let pLeftX = getPerspectiveX(player.y, 0);
  let pRightX = getPerspectiveX(player.y, canvas.width);
  let playerWidth = pRightX - pLeftX;

  return bulletWidth / playerWidth;
}

// 初始化遊戲
function initGame(){
  vanishPoint = { x: canvas.width/2, y: canvas.height*(31/48) }; 
  bottomBoundaryY = canvas.height;
    
  player = { x: canvas.width/2, y: bottomBoundaryY };
  
  let enemyY = vanishPoint.y + (1/5) * RICO_MATH.ViewDeep;
  let initScale = getEnemyScale(enemyY);
  enemy = { x: vanishPoint.x, y: enemyY, dir: 1, scale: initScale.scale };

  bullets = [];
  enemyBullets = [];
  playerHP = maxHP;
  enemyHP = maxHP;
  gameOver = false;
  toggleGridBtn.style.display = "block";
  restartBtn.style.display = "none";
  lastPlayerShot = 0;
  lastEnemyShot = 0;
  lastEnemyDodge = 0;

  resizeCanvas(); // 確保初始畫面正確
}

const playerMaxSpeed = () => canvas.width/5 / 60;
let targetX = 0;

// 滑鼠事件
canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  targetX = e.clientX - rect.left;
});
canvas.addEventListener("click", shootBullet);

// 觸控事件
canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  targetX = e.touches[0].clientX - rect.left;
}, { passive: false });
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  shootBullet();
}, { passive: false });

function shootBullet() {
  if(gameOver) return;
  let now = Date.now();
  if(now - lastPlayerShot < shotCooldown) return;
  lastPlayerShot = now;
  bullets.push({ startX: player.x, startY: player.y - basePlayerH*0.5, x: player.x, y: player.y - basePlayerH*0.5, progress: 0 });
  shootSound.currentTime = 0;
  shootSound.play();
}

// 預測子彈
const predictionFactor = 0.5;
function predictBulletPosition(b, deltaProgress){
  let futureProgress = b.progress + deltaProgress;
  let futureX = (1-futureProgress)*b.startX + futureProgress*vanishPoint.x;
  let futureY = (1-futureProgress)*b.startY + futureProgress*vanishPoint.y;
  return { x: futureX, y: futureY };
}

setInterval(() => {
  if(gameOver) return;
  let now = Date.now();
  if(now - lastEnemyShot < shotCooldown) return;

  let danger = bullets.some(b => Math.abs(b.x - enemy.x) < 30 && b.y < enemy.y);
  if(danger && now - lastEnemyDodge > dodgeCooldown){ 
    enemy.dir *= -1; 
    lastEnemyDodge = now;
    return; 
  }

  let slope = (enemy.x - vanishPoint.x) / (enemy.y - vanishPoint.y);
  let targetX = vanishPoint.x + slope * RICO_MATH.ViewDeep;
  if(Math.abs(targetX - player.x) < 30){
    lastEnemyShot = now;
	enemyBullets.push({ startX: enemy.x, startY: enemy.y, x: enemy.x, y: enemy.y, progress: 0 });
  }
}, 50);

// 玩家子彈速度：底部快 → 消失點慢
function getPlayerBulletSpeed(y, startX, startY) {
  let slope = Math.abs((startX - vanishPoint.x) / (startY - vanishPoint.y));
  let factor = (y - vanishPoint.y) / (bottomBoundaryY - vanishPoint.y); 
  return 0.02 * factor * (1 + slope) + 0.001;
}

// 敵人子彈速度：消失點慢 → 底部快 
function getEnemyBulletSpeed(y, startX, startY) { 
  let slope = Math.abs((startX - vanishPoint.x) / (startY - vanishPoint.y)); 
  let factor = (y - vanishPoint.y) / (bottomBoundaryY - vanishPoint.y); 
  return 0.001 + 0.02 * factor * (1 + slope);
}



function update() {
  if(gameOver) return;

  let pLeftX = getPerspectiveX(player.y, 0);
  let pRightX = getPerspectiveX(player.y, canvas.width);
  let playerWidth = pRightX - pLeftX;

  let dx = targetX - player.x;
  let maxSpeed = playerMaxSpeed();
  if(Math.abs(dx) > maxSpeed) dx = maxSpeed * Math.sign(dx);
  player.x += dx;

  if(player.x - basePlayerW/2 < pLeftX) player.x = pLeftX + basePlayerW/2;
  if(player.x + basePlayerW/2 > pRightX) player.x = pRightX - basePlayerW/2;
 
  bullets.forEach(b => {
    let speed = getPlayerBulletSpeed(b.y, b.startX, b.startY);	
	b.progress += speed;
	
    b.x = (1-b.progress)*b.startX + b.progress*vanishPoint.x;
    b.y = (1-b.progress)*b.startY + b.progress*vanishPoint.y;
  });
  bullets = bullets.filter(b => b.progress < 1);

  enemyBullets.forEach(b => {
    let speed = getEnemyBulletSpeed(b.y, b.startX, b.startY); 
	b.progress += speed;
	
    let slope = (b.startX - vanishPoint.x) / (b.startY - vanishPoint.y);
    let targetX = vanishPoint.x + slope * RICO_MATH.ViewDeep;
    let targetY = bottomBoundaryY;
    b.x = (1-b.progress)*b.startX + b.progress*targetX;
    b.y = (1-b.progress)*b.startY + b.progress*targetY;
  });
    enemyBullets = enemyBullets.filter(b => b.progress < 1);

  // 敵人移動邊界判斷
  let enemyCalc = getEnemyScale(enemy.y);
  enemy.scale = enemyCalc.scale;
  let enemyWidth = enemyCalc.width;

  let enemyW = basePlayerW * enemy.scale;
  let enemySpeed = playerMaxSpeed() * (enemyWidth / playerWidth);

  enemy.x += enemy.dir * enemySpeed;
  if(enemy.x - enemyW/2 <= getPerspectiveX(enemy.y, 0)){ 
    enemy.x = getPerspectiveX(enemy.y, 0) + enemyW/2; 
    enemy.dir = 1; 
  }
  if(enemy.x + enemyW/2 >= getPerspectiveX(enemy.y, canvas.width)){ 
    enemy.x = getPerspectiveX(enemy.y, canvas.width) - enemyW/2; 
    enemy.dir = -1; 
  }
  // 玩家子彈碰撞判定
  bullets.forEach(b => {
    let dx = b.x - enemy.x;
    let dy = b.y - enemy.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    let hitbox = enemyW / 2;
    if(dist < hitbox){
      enemyHP--; 
      b.progress = 1;
      hitSound.currentTime = 0;
      hitSound.play();
    }
  });

  // 敵人子彈碰撞判定
  enemyBullets.forEach(b => {
    let dx = b.x - player.x;
    let dy = b.y - player.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    let hitbox = basePlayerW / 2;
    if(dist < hitbox){
      playerHP--; 
      b.progress = 1;
      hitSound.currentTime = 0;
      hitSound.play();
    }
  });

  // 遊戲結束判斷
  if(playerHP <= 0 || enemyHP <= 0)
   { 
     gameOver = true; 
     restartBtn.textContent = "重新開始";
     restartBtn.style.display = "block"; 
	
     bgm.pause();
     bgm.currentTime=0;
	
     if(playerHP <=0) 
      {
	     failSound.currentTime = 0;
	     failSound.play();
      } 
     else 
      {
	     winSound.currentTime = 0;
	     winSound.play();
      }
   }
   
}

// 血條顯示
function drawHPAbove(x, y, hp, maxHP, charWidth, charHeight, isEnemy=false){
  if(hp >= maxHP) return;
  
  ctx.save();
  ctx.globalAlpha = 0.7;

  let barHeight = isEnemy ? Math.max(6, 10 * (charHeight/basePlayerH)) : 10;

  ctx.fillStyle = "gray";
  ctx.fillRect(x - charWidth/2, y - charHeight - 10, charWidth, barHeight);

  let color = "green";
  if(hp <= 3) color = "yellow";
  if(hp <= 2) color = "red";
  if(hp === 1 && Math.floor(Date.now()/300) % 2 === 0) color = "rgba(255,0,0,0)";

  ctx.fillStyle = color;
  ctx.fillRect(x - charWidth/2, y - charHeight - 10, charWidth * (hp/maxHP), barHeight);

  ctx.restore();
}

// 繪製格線
function drawGrid() {
  ctx.strokeStyle = "gray";
  gridLines.forEach(line => {
    ctx.beginPath();
    ctx.moveTo(line.x, bottomBoundaryY);
    ctx.lineTo(vanishPoint.x, vanishPoint.y);
    ctx.stroke();
  });
  ctx.beginPath();
  ctx.moveTo(0, bottomBoundaryY);
  ctx.lineTo(canvas.width, bottomBoundaryY);
  ctx.stroke();
}

// 繪製畫面
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 背景
  let gradient = ctx.createLinearGradient(0,0,0,canvas.height);
  gradient.addColorStop(0,"skyblue");
  gradient.addColorStop(1,"white");
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

  // 格線
  if(showGrid){
    drawGrid();
  }

  if(gameOver)
   {
      ctx.fillStyle = "yellow";
      ctx.font = "40px Arial";
      ctx.fillText(playerHP <= 0 ? "敵人勝利!" : "玩家勝利!", canvas.width/2-100, canvas.height/2);
	  if(playerHP <= 0) 
	  { 
	   ctx.save();
       if(targetX > player.x)       { facingRight = -1; } 
       else if(targetX < player.x)  { facingRight =  1; }
       ctx.scale(facingRight,1);
       ctx.drawImage(failImg, facingRight*player.x- basePlayerW, player.y - basePlayerH/1.3, basePlayerW*1.7, basePlayerH/1.3);
       ctx.restore();
	  }
      return;
   }

  // 敵人
let enemyW = basePlayerW * enemy.scale;
let enemyH = basePlayerH * enemy.scale;

ctx.save();
if(enemy.dir > 0){ // 往右 → 鏡像
  ctx.scale(-1,1);
  ctx.drawImage(enemyImg, -enemy.x - enemyW/2, enemy.y - enemyH, enemyW, enemyH);
} else { // 往左 → 正常
  ctx.drawImage(enemyImg, enemy.x - enemyW/2, enemy.y - enemyH, enemyW, enemyH);
}
ctx.restore();

drawHPAbove(enemy.x, enemy.y, enemyHP, maxHP, enemyW, enemyH, true);


  // 子彈
  ctx.fillStyle = "yellow";
  bullets.forEach(b => {
    let scale = getBulletScale(b.y);
    ctx.beginPath();
    ctx.arc(b.x, b.y, (basePlayerW/8) * scale, 0, Math.PI*2);
    ctx.fill();
  });

  ctx.fillStyle = "orange";
  enemyBullets.forEach(b => {
    let scale = getBulletScale(b.y);
    ctx.beginPath();
    ctx.arc(b.x, b.y, (basePlayerW/8) * scale, 0, Math.PI*2);
    ctx.fill();
  });

  // 玩家
  ctx.save();
  if(targetX > player.x)       { facingRight = -1; } 
  else if(targetX < player.x)  { facingRight =  1; }
  ctx.scale(facingRight,1);
  ctx.drawImage(playerImg, facingRight*player.x- basePlayerW/2, player.y - basePlayerH, basePlayerW, basePlayerH);
  ctx.restore();

  drawHPAbove(player.x, player.y, playerHP, maxHP, basePlayerW, basePlayerH, false);


}

// 遊戲迴圈
function gameLoop() {
  update();
  draw();
  if(!gameOver) requestAnimationFrame(gameLoop);
}

// 開始/重新開始按鈕邏輯
restartBtn.addEventListener("click", () => {
  initGame();
  bgm.play();
  gameLoop();
});
</script>
</body>
</html>
