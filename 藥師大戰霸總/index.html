<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>透視射擊遊戲（邏輯重構完整版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; touch-action: none; background: black; height: 100%; }
    canvas { display: block; margin: auto; background: black; touch-action: none; }
    #lobbyUI {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95); padding: 25px; border-radius: 15px;
      color: white; text-align: center; min-width: 280px; z-index: 100;
      border: 1px solid #444; font-family: Arial, sans-serif;
    }
    #playerList { margin: 15px 0; max-height: 250px; overflow-y: auto; background: #111; border: 1px solid #333; }
    .player-item { padding: 10px; border-bottom: 1px solid #222; cursor: pointer; font-size: 14px; }
    #playAIBtn { width: 100%; padding: 10px; font-size: 18px; background: #444; color: white; border: none; cursor: pointer; }
    #toggleGridBtn {
      position: absolute; bottom: 10px; left: 10px; padding: 10px 20px;
      font-size: 14px; background: rgba(68, 68, 68, 0.5); color: white;
      border: none; cursor: pointer; display: none; z-index: 101;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="lobbyUI">
  <h2 id="lobbyStatus">遊戲大廳</h2>
  <div id="playerList"></div>
  <button id="playAIBtn">開始 AI 對戰</button>
</div>

<button id="toggleGridBtn">顯示格線</button>

<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script> 
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
<script>
// --- 基礎定義與 Firebase ---
let lastFirebaseUpdateTime = 0;
const FIREBASE_TICK_RATE = 20; 

const firebaseConfig = {
  apiKey: "AIzaSyDsQKp4MbIZiI_K95S8vy4q_q9pfx1c3aw",
  authDomain: "my-shooting-game-68732.firebaseapp.com",
  databaseURL: "https://my-shooting-game-68732-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "my-shooting-game-68732",
  storageBucket: "my-shooting-game-68732.appspot.com",
  messagingSenderId: "212506441565",
  appId: "1:212506441565:web:8fe492bef5abd7be711ab4"
};

const app = firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const playerId = Math.random().toString(36).substr(2,9);
const userRef = db.ref("users/" + playerId);
userRef.set({ online: true, hp: 5, opponentId: null, request: null });
userRef.onDisconnect().remove();

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const toggleGridBtn = document.getElementById("toggleGridBtn");
const lobbyUI = document.getElementById("lobbyUI");
const playerListDiv = document.getElementById("playerList");
const playAIBtn = document.getElementById("playAIBtn");

// --- 變數定義 ---
let facingRight = 1;
let basePlayerW, basePlayerH;
let player, enemy, bullets, enemyBullets, vanishPoint, bottomBoundaryY, playerHP, enemyHP, gameOver = true;
let lastPlayerShot = 0, lastEnemyShot = 0, lastEnemyDodge = 0;
const shotCooldown = 500, dodgeCooldown = 200, maxHP = 5;
let otherPlayers = {};
let opponentId = null;
let pendingInviteId = null;
let showGrid = false;
const gridLines = [];

// --- 資源加載 ---
const playerImg = new Image(); playerImg.src = "玩家.png";
const enemyImg = new Image(); enemyImg.src = "敵人.png";
const bgImg = new Image(); bgImg.src = "背景.png";
const failImg = new Image(); failImg.src = "fail.png";
const bgm = new Audio("bgm.mp3"); bgm.loop = true; bgm.volume = 0.5;
const shootSound = new Audio("發射.mp3");
const hitSound = new Audio("被擊中.mp3");
const winSound = new Audio("win.mp3");
const failSound = new Audio("fail.mp3");

// --- RICO_MATH：數學計算重構 ---
const RICO_MATH = {
  get ViewDeep() { 
    let RICO_BUF = bottomBoundaryY - vanishPoint.y; 
    return (RICO_BUF < 1) ? 1 : RICO_BUF; 
  },
  getVisualProgress: (p) => Math.pow(p, 1.5),
  // 核心轉換：將 0~1 的比例轉為實際 Canvas X
  getCanvasXByRatio: (ratio, y, isMirror = false) => {
    const finalRatio = isMirror ? (1 - ratio) : ratio;
    const leftX = getPerspectiveX(y, 0);
    const rightX = getPerspectiveX(y, canvas.width);
    return leftX + finalRatio * (rightX - leftX);
  },
  // 獲取特定 Y 的縮放數據
  getScaleAtY: (y) => {
    const currentRange = getPerspectiveX(y, canvas.width) - getPerspectiveX(y, 0);
    const baseRange = getPerspectiveX(bottomBoundaryY, canvas.width) - getPerspectiveX(bottomBoundaryY, 0);
    return { scale: (currentRange / baseRange), width: currentRange };
  },
  // 統一處理子彈狀態 (包含 PVP 映射)
  getBulletData: (b, isEnemy, isPVP, enemyY) => {
    let bx, by;
    if (isPVP && isEnemy) {
      const vp = RICO_MATH.getVisualProgress(b.progress);
      bx = RICO_MATH.getCanvasXByRatio(b.xRatio, (1 - vp) * enemyY + vp * bottomBoundaryY, true);
      by = (1 - vp) * enemyY + vp * bottomBoundaryY;
    } else {
      bx = b.x; by = b.y;
    }
    const s = RICO_MATH.getScaleAtY(by).scale;
    return { x: bx, y: by, scale: s, radius: Math.max((basePlayerW / 8) * s, 3) };
  }
};

// 輔助函式
function getPerspectiveX(y, baseX){ return vanishPoint.x + (baseX - vanishPoint.x) * ((y - vanishPoint.y) / RICO_MATH.ViewDeep); }

// --- 狀態獲取：整合 update 與 draw 共用數據 ---
function getCurrentGameState() {
  const state = {
    player: { x: player?.x, y: player?.y, w: basePlayerW, h: basePlayerH, hp: playerHP, facing: targetX > player?.x ? -1 : 1 },
    enemy: { x: 0, y: 0, w: 0, h: 0, hp: 0, label: "", color: "", isPVP: false, facing: 1, bullets: [] }
  };

  const enemyY = vanishPoint.y + (1/5) * RICO_MATH.ViewDeep;
  const eScale = RICO_MATH.getScaleAtY(enemyY);

  if (opponentId && otherPlayers[opponentId]) {
    const op = otherPlayers[opponentId];
    state.enemy = {
      isPVP: true,
      x: RICO_MATH.getCanvasXByRatio(op.x, enemyY, true),
      y: enemyY,
      w: basePlayerW * eScale.scale,
      h: basePlayerH * eScale.scale,
      hp: op.hp,
      label: "連線對手",
      color: "cyan",
      facing: op.x > 0.5 ? 1 : -1,
      bullets: op.bullets || []
    };
  } else if (enemy) {
    state.enemy = {
      isPVP: false,
      x: enemy.x,
      y: enemy.y,
      w: basePlayerW * eScale.scale,
      h: basePlayerH * eScale.scale,
      hp: enemyHP,
      label: "AI 敵人",
      color: "white",
      facing: enemy.dir === 1 ? -1 : 1,
      bullets: enemyBullets
    };
  }
  return state;
}

// --- 初始化與 Canvas 管理 ---
function initGrid(){
  gridLines.length = 0;
  for(let i=0; i<30; i++){ gridLines.push({ x: (canvas.width/30)*i }); }
}

function resizeCanvas() {
  let oldW = canvas.width, oldH = canvas.height;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight * 0.9;
  let NewSizeWScale = canvas.width / oldW;
  let NewSizeHScale = canvas.height / oldH;
  basePlayerW = canvas.width / 9;
  basePlayerH = basePlayerW * (50/35);
  vanishPoint = { x: canvas.width/2, y: canvas.height*(31/48) };
  bottomBoundaryY = canvas.height;
  initGrid();
  if(player){ player.x *= NewSizeWScale; player.y *= NewSizeHScale; }
  if(enemy){ enemy.x *= NewSizeWScale; enemy.y *= NewSizeHScale; }
  if(bullets) bullets.forEach(b => { b.startX *= NewSizeWScale; b.startY *= NewSizeHScale; b.x *= NewSizeWScale; b.y *= NewSizeHScale; });
  if(enemyBullets) enemyBullets.forEach(b => { b.startX *= NewSizeWScale; b.startY *= NewSizeHScale; b.x *= NewSizeWScale; b.y *= NewSizeHScale; });
}

// --- 遊戲邏輯 ---
function update() {
  if(gameOver || !player) return;
  const game = getCurrentGameState();

  // 1. 玩家移動
  let pLeftLimit = getPerspectiveX(player.y, 0) + basePlayerW/2;
  let pRightLimit = getPerspectiveX(player.y, canvas.width) - basePlayerW/2;
  let dx = targetX - player.x, mSpeed = canvas.width/5 / 60;
  if(Math.abs(dx) > mSpeed) dx = mSpeed * Math.sign(dx);
  player.x = Math.max(pLeftLimit, Math.min(player.x + dx, pRightLimit));

  // 2. 玩家子彈更新
  bullets.forEach(b => {
    let speed = 0.02 * ((b.y - vanishPoint.y) / (bottomBoundaryY - vanishPoint.y)) * (1 + Math.abs((b.startX - vanishPoint.x) / (b.startY - vanishPoint.y))) + 0.001;
    b.progress += speed; 
    b.x = (1-b.progress)*b.startX + b.progress*vanishPoint.x; 
    b.y = (1-b.progress)*b.startY + b.progress*vanishPoint.y;
  });
  bullets = bullets.filter(b => b.progress < 1);

  // 3. 碰撞檢查
  if(!game.enemy.isPVP) updateAI(game.enemy.w);

  // 我方射擊對手
  bullets.forEach(b => {
    if(Math.sqrt((b.x - game.enemy.x)**2 + (b.y - game.enemy.y)**2) < game.enemy.w/2) {
      if(!game.enemy.isPVP) enemyHP--; 
      b.progress = 1; hitSound.currentTime = 0; hitSound.play();
    }
  });

  // 對手射擊我方
  game.enemy.bullets.forEach(b => {
    const bData = RICO_MATH.getBulletData(b, true, game.enemy.isPVP, game.enemy.y);
    const hitRange = game.enemy.isPVP ? Math.max(bData.radius, 20) : basePlayerW / 2;
    if (Math.sqrt((bData.x - player.x) ** 2 + (bData.y - player.y) ** 2) < hitRange) {
      playerHP--; b.progress = 1.1; hitSound.currentTime = 0; hitSound.play();
    }
  });

  // 4. 結束判定
  if(playerHP <= 0 || (game.enemy.hp <= 0 && !game.enemy.isPVP) || (game.enemy.isPVP && game.enemy.hp <= 0)){
    gameOver = true; bgm.pause(); (playerHP <= 0 ? failSound : winSound).play();
    setTimeout(() => { userRef.update({ opponentId: null }); lobbyUI.style.display = "block"; }, 3000);
  }
  syncToFirebase();
}

function updateAI(enemyW) {
  const now = Date.now(), eScale = RICO_MATH.getScaleAtY(enemy.y);
  const danger = bullets.some(b => Math.abs(b.x - enemy.x) < 30 && b.y < enemy.y);
  if(danger && now - lastEnemyDodge > dodgeCooldown){ enemy.dir *= -1; lastEnemyDodge = now; }
  
  let enemySpeed = (canvas.width/5 / 60) * (eScale.width / (getPerspectiveX(bottomBoundaryY, canvas.width) - getPerspectiveX(bottomBoundaryY, 0)));
  enemy.x += enemy.dir * enemySpeed;
  if(enemy.x - enemyW/2 <= getPerspectiveX(enemy.y, 0)){ enemy.x = getPerspectiveX(enemy.y, 0) + enemyW/2; enemy.dir = 1; }
  if(enemy.x + enemyW/2 >= getPerspectiveX(enemy.y, canvas.width)){ enemy.x = getPerspectiveX(enemy.y, canvas.width) - enemyW/2; enemy.dir = -1; }

  if(now - lastEnemyShot > shotCooldown){
    let slope = (enemy.x - vanishPoint.x) / (enemy.y - vanishPoint.y);
    if(Math.abs((vanishPoint.x + slope * RICO_MATH.ViewDeep) - player.x) < 30){
      lastEnemyShot = now; enemyBullets.push({ startX: enemy.x, startY: enemy.y, x: enemy.x, y: enemy.y, progress: 0 });
    }
  }

  enemyBullets.forEach(b => {
    b.progress += 0.001 + 0.02 * ((b.y - vanishPoint.y) / (bottomBoundaryY - vanishPoint.y)) * (1 + Math.abs((b.startX - vanishPoint.x) / (b.startY - vanishPoint.y)));
    let slope = (b.startX - vanishPoint.x) / (b.startY - vanishPoint.y);
    b.x = (1-b.progress)*b.startX + b.progress * (vanishPoint.x + slope * RICO_MATH.ViewDeep);
    b.y = (1-b.progress)*b.startY + b.progress * bottomBoundaryY;
  });
  enemyBullets = enemyBullets.filter(b => b.progress < 1);
}

// --- 繪製 ---
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  let grad = ctx.createLinearGradient(0,0,0,canvas.height);
  grad.addColorStop(0,"skyblue"); grad.addColorStop(1,"white");
  ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

  if(showGrid){
    ctx.strokeStyle = "gray";
    gridLines.forEach(line => { ctx.beginPath(); ctx.moveTo(line.x, bottomBoundaryY); ctx.lineTo(vanishPoint.x, vanishPoint.y); ctx.stroke(); });
    ctx.beginPath(); ctx.moveTo(0, bottomBoundaryY); ctx.lineTo(canvas.width, bottomBoundaryY); ctx.stroke();
  }

  if(!player) return;
  const game = getCurrentGameState();

  if(gameOver){
    ctx.fillStyle = "yellow"; ctx.font = "40px Arial"; ctx.textAlign = "center";
    ctx.fillText(playerHP <= 0 ? "敵人勝利!" : "玩家勝利!", canvas.width/2, canvas.height/2);
    if(playerHP <= 0){ 
      ctx.save(); let fDir = game.player.facing;
      ctx.scale(fDir, 1); ctx.drawImage(failImg, fDir*game.player.x - basePlayerW, game.player.y - basePlayerH/1.3, basePlayerW*1.7, basePlayerH/1.3); ctx.restore();
    }
    return;
  }

  // 畫對手/AI
  ctx.save(); ctx.translate(game.enemy.x, game.enemy.y); ctx.scale(game.enemy.facing, 1);
  ctx.drawImage(enemyImg, -game.enemy.w/2, -game.enemy.h, game.enemy.w, game.enemy.h); ctx.restore();
  ctx.fillStyle = game.enemy.color; ctx.font = "bold 16px Arial"; ctx.textAlign = "center";
  ctx.fillText(game.enemy.label, game.enemy.x, game.enemy.y - game.enemy.h - 25);
  drawHPAbove(game.enemy.x, game.enemy.y, game.enemy.hp, maxHP, game.enemy.w, game.enemy.h, true);

  // 畫敵人子彈
  game.enemy.bullets.forEach(b => {
    const d = RICO_MATH.getBulletData(b, true, game.enemy.isPVP, game.enemy.y);
    ctx.beginPath(); ctx.fillStyle = "orange"; ctx.arc(d.x, d.y, d.radius, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; ctx.lineWidth = 2 * d.scale; ctx.stroke();
  });

  // 畫玩家子彈
  bullets.forEach(b => {
    const d = RICO_MATH.getBulletData(b, false, false, 0);
    ctx.beginPath(); ctx.fillStyle = "yellow"; ctx.arc(d.x, d.y, d.radius, 0, Math.PI*2); ctx.fill();
  });

  // 畫玩家
  ctx.save(); ctx.scale(game.player.facing, 1);
  ctx.drawImage(playerImg, game.player.facing*game.player.x - basePlayerW/2, game.player.y - basePlayerH, basePlayerW, basePlayerH);
  ctx.restore();
  drawHPAbove(game.player.x, game.player.y, game.player.hp, maxHP, basePlayerW, basePlayerH, false);
}

// --- 輔助邏輯與事件 ---
function syncToFirebase() {
  const now = Date.now();
  if (now - lastFirebaseUpdateTime < FIREBASE_TICK_RATE || !player || gameOver) return;
  lastFirebaseUpdateTime = now;
  userRef.update({ 
    x: player.x / canvas.width, hp: playerHP, 
    bullets: bullets.map(b => ({ xRatio: b.startX / canvas.width, progress: b.progress }))
  });
}

function drawHPAbove(x, y, hp, max, w, h, isE){
  if(hp >= max) return;
  ctx.save(); ctx.globalAlpha = 0.7;
  let bh = isE ? Math.max(6, 10*(h/basePlayerH)) : 10;
  ctx.fillStyle = "gray"; ctx.fillRect(x - w/2, y - h - 10, w, bh);
  let color = "green"; if(hp<=3) color="yellow"; if(hp<=2) color="red";
  if(hp===1 && Math.floor(Date.now()/300)%2===0) color="rgba(255,0,0,0)";
  ctx.fillStyle = color; ctx.fillRect(x - w/2, y - h - 10, w*(hp/max), bh); ctx.restore();
}

function initGame(){
  vanishPoint = { x: canvas.width/2, y: canvas.height*(31/48) }; 
  bottomBoundaryY = canvas.height;
  player = { x: canvas.width/2, y: bottomBoundaryY };
  enemy = { x: vanishPoint.x, y: vanishPoint.y + (1/5) * (bottomBoundaryY - vanishPoint.y), dir: 1 };
  bullets = []; enemyBullets = []; playerHP = maxHP; enemyHP = maxHP; gameOver = false;
  toggleGridBtn.style.display = "block"; resizeCanvas();
  userRef.set({ x: player.x / canvas.width, hp: playerHP, bullets: [], opponentId: opponentId });
}

let targetX = 0;
canvas.addEventListener("mousemove", e => { targetX = e.clientX - canvas.getBoundingClientRect().left; });
canvas.addEventListener("click", shootBullet);
canvas.addEventListener("touchstart", e => { e.preventDefault(); targetX = e.touches[0].clientX - canvas.getBoundingClientRect().left; shootBullet(); }, { passive: false });
canvas.addEventListener("touchmove", e => { e.preventDefault(); targetX = e.touches[0].clientX - canvas.getBoundingClientRect().left; }, { passive: false });

function shootBullet() {
  if(gameOver || !player || Date.now() - lastPlayerShot < shotCooldown) return;
  lastPlayerShot = Date.now();
  bullets.push({ startX: player.x, startY: player.y - basePlayerH*0.5, x: player.x, y: player.y - basePlayerH*0.5, progress: 0 });
  shootSound.currentTime = 0; shootSound.play();
}

function gameLoop() { update(); draw(); if(!gameOver) requestAnimationFrame(gameLoop); }

toggleGridBtn.addEventListener("click", () => { showGrid = !showGrid; toggleGridBtn.textContent = showGrid ? "隱藏格線" : "顯示格線"; });
playAIBtn.onclick = () => { opponentId = null; lobbyUI.style.display = "none"; initGame(); bgm.play(); gameLoop(); };

window.addEventListener("resize", resizeCanvas);
window.addEventListener("orientationchange", resizeCanvas);

// Firebase 監聽
db.ref("users").on("value", snapshot => {
  otherPlayers = snapshot.val() || {};
  const me = otherPlayers[playerId];
  playerListDiv.innerHTML = "";
  Object.keys(otherPlayers).forEach(id => {
    if (id === playerId) return;
    const p = otherPlayers[id], item = document.createElement("div");
    item.className = "player-item"; item.textContent = id + (p.opponentId ? " (對戰中)" : " (在線)");
    if (!p.opponentId) item.onclick = () => { db.ref(`users/${id}/request`).set({ from: playerId }); };
    playerListDiv.appendChild(item);
  });
  if (me?.request && gameOver) {
    if (confirm("來自 " + me.request.from + " 的挑戰？")) {
      opponentId = me.request.from; userRef.update({ request: null, opponentId: opponentId });
      db.ref(`users/${opponentId}`).update({ opponentId: playerId });
      lobbyUI.style.display = "none"; initGame(); bgm.play(); gameLoop();
    } else { userRef.update({ request: null }); }
  }
  if (me?.opponentId && !opponentId && gameOver) {
    opponentId = me.opponentId; lobbyUI.style.display = "none"; initGame(); bgm.play(); gameLoop();
  }
});

resizeCanvas(); draw();
</script>
</body>
</html>