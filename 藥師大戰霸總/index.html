<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>透視射擊遊戲（邏輯重構完整版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; touch-action: none; background: black; height: 100%; }
    canvas { display: block; margin: auto; background: black; touch-action: none; }
    #lobbyUI {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95); padding: 25px; border-radius: 15px;
      color: white; text-align: center; min-width: 280px; z-index: 100;
      border: 1px solid #444; font-family: Arial, sans-serif;
    }
    #playerList { margin: 15px 0; max-height: 250px; overflow-y: auto; background: #111; border: 1px solid #333; }
    .player-item { padding: 10px; border-bottom: 1px solid #222; cursor: pointer; font-size: 14px; }
    #playAIBtn { width: 100%; padding: 10px; font-size: 18px; background: #444; color: white; border: none; cursor: pointer; }
    #toggleGridBtn {
      position: absolute; bottom: 10px; left: 10px; padding: 10px 20px;
      font-size: 14px; background: rgba(68, 68, 68, 0.5); color: white;
      border: none; cursor: pointer; display: none; z-index: 101;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="lobbyUI">
  <h2 id="lobbyStatus">遊戲大廳</h2>
  <div id="playerList"></div>
  <button id="playAIBtn">開始 AI 對戰</button>
</div>

<button id="toggleGridBtn">顯示格線</button>

<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script> 
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
<script>

let battleTimer = null;
let isCoolingDown = false; // 對戰冷卻狀態

async function checkNickname() {
    let savedName = localStorage.getItem("playerNickname");
    
    // 檢查 Firebase 是否已有資料，若無則要求輸入
    const snapshot = await userRef.child("name").get();
    const cloudName = snapshot.val();

    if (!cloudName) {
        if (!savedName) {
            savedName = prompt("請輸入你的暱稱 (12字內):", "新玩家");
            savedName = savedName ? savedName.substring(0, 12) : "匿名玩家";
        }
        await userRef.update({ name: savedName });
        localStorage.setItem("playerNickname", savedName);
    }
}


let lastOpponentX = 0.5; // 預設中間
let opponentFacing = 1;  // 預設朝向

// --- 基礎定義與 Firebase ---
let lastFirebaseUpdateTime = 0;
const FIREBASE_TICK_RATE = 20; 
// --- 統一子彈物理常數 ---
const BULLET_FLIGHT_TIME = 1200; // 總飛行時間 (ms)
const SPEED_EXPONENT = 2.5;      // 提高指數，讓子彈在靠近玩家（變大）時產生更劇烈的加速感
// --- 統一 Y 軸飛行區間 ---
const Y_START = 1.0; // 玩家所在的 Y 比例 (Canvas 底部)
const Y_END = 0.2;   // 敵人所在的 Y 比例 (靠近消失點)



const firebaseConfig = {
  apiKey: "AIzaSyDsQKp4MbIZiI_K95S8vy4q_q9pfx1c3aw",
  authDomain: "my-shooting-game-68732.firebaseapp.com",
  databaseURL: "https://my-shooting-game-68732-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "my-shooting-game-68732",
  storageBucket: "my-shooting-game-68732.appspot.com",
  messagingSenderId: "212506441565",
  appId: "1:212506441565:web:8fe492bef5abd7be711ab4"
};

const app = firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const playerId = Math.random().toString(36).substr(2,9);
const userRef = db.ref("users/" + playerId);
userRef.set({ online: true, hp: 5, opponentId: null, request: null });
userRef.onDisconnect().remove();

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const toggleGridBtn = document.getElementById("toggleGridBtn");
const lobbyUI = document.getElementById("lobbyUI");
const playerListDiv = document.getElementById("playerList");
const playAIBtn = document.getElementById("playAIBtn");

// --- 變數定義 ---
let facingRight = 1;
let basePlayerW, basePlayerH;
let player, enemy, bullets, enemyBullets, vanishPoint, bottomBoundaryY, playerHP, enemyHP, gameOver = true;
let lastPlayerShot = 0, lastEnemyShot = 0, lastEnemyDodge = 0;
const shotCooldown = 500, dodgeCooldown = 200, maxHP = 5;
let otherPlayers = {};

// --- 自動化與節流配置 ---
let idleTimer;
const IDLE_TIMEOUT = 180000; // 3分鐘 (180,000 毫秒)

function resetIdleTimer() {
  clearTimeout(idleTimer);
  // 如果目前是離線狀態（在大廳被自動關閉後），點擊畫面可重連
  if (lobbyUI.style.display !== "none" && lobbyStatus.textContent.includes("離線")) {
      location.reload(); // 最簡單的重連方式是重新載入
  }
  idleTimer = setTimeout(handleIdleTimeout, IDLE_TIMEOUT);
}

function handleIdleTimeout() {
  if (!gameOver) {
    // 1. 遊戲中：自動切換成本地 AI 模式
    console.log("偵測到閒置：切換為本地 AI 模式");
    opponentId = null; // 斷開與對手的對聯
    stopLobbyListen(); // 停止接收 Firebase 數據
    // 這裡不中斷遊戲，讓 update() 繼續運行 AI 邏輯
  } else {
    // 2. 大廳中：關閉遊戲並斷開連線
    console.log("偵測到閒置：關閉大廳連線");
    userRef.remove(); // 從 Firebase 刪除自己的 ID
    firebase.database().goOffline(); // 徹底斷開 WebSocket 流量
    lobbyStatus.textContent = "閒置過久，已進入離線模式";
    lobbyStatus.style.color = "red";
    playerListDiv.innerHTML = "<p>請重新整理頁面以啟動連線</p>";
  }
}

// 此因子控制子彈基礎速度。公式為：速度 = 半徑 * FACTOR
const BULLET_SPEED_FACTOR = 0.0016;

let opponentId = null;
let pendingInviteId = null;
let showGrid = false;
const gridLines = [];

// --- 資源加載 ---
const playerImg = new Image(); playerImg.src = "玩家.png";
const enemyImg = new Image(); enemyImg.src = "敵人.png";
const bgImg = new Image(); bgImg.src = "背景.png";
const failImg = new Image(); failImg.src = "fail.png";
const bgm = new Audio("bgm.mp3"); bgm.loop = true; bgm.volume = 0.5;
const shootSound = new Audio("發射.mp3");
const hitSound = new Audio("被擊中.mp3");
const winSound = new Audio("win.mp3");
const failSound = new Audio("fail.mp3");

// --- RICO_MATH：數學計算重構 ---
const RICO_MATH = {
  get ViewDeep() { 
    let RICO_BUF = bottomBoundaryY - vanishPoint.y; 
    return (RICO_BUF < 1) ? 1 : RICO_BUF; 
  },
  // 移除 Math.min(..., 1)，允許 progress 超過 1.0 往身後飛
  getTimeProgress: (timestamp) => (Date.now() - timestamp) / BULLET_FLIGHT_TIME,
  // 修改邏輯：讓進度在靠近 0 (玩家端) 時變化最快，靠近 1 (消失點) 時變慢
  // 核心邏輯：p 是 0~1 的時間進度。
  // 我們定義：越靠近玩家(Canvas底部)，視覺位移越劇烈。
  // 核心邏輯：確保無論是誰射的，只要 y 靠近 bottomBoundaryY，速度(位移變化率)就達到最高
  getVisualProgress: (p, isComingTowardPlayer = false) => {
    if (isComingTowardPlayer) {
      // 敵人射向玩家：p從0(遠)到1(近)。使用 p^E，當 p 靠近 1 時速度極快
      return Math.pow(p, SPEED_EXPONENT); 
    } else {
      // 玩家射向敵人：p從0(近)到1(遠)。使用 1-(1-p)^E，當 p 靠近 0 時速度極快
      return 1 - Math.pow(1 - p, SPEED_EXPONENT);
    }
  },
  // 核心轉換：將 0~1 的比例轉為實際 Canvas X
  getCanvasXByRatio: (ratio, y, isMirror = false) => {
    const finalRatio = isMirror ? (1 - ratio) : ratio;
    const leftX = getPerspectiveX(y, 0);
    const rightX = getPerspectiveX(y, canvas.width);
    return leftX + finalRatio * (rightX - leftX);
  },
  // 獲取特定 Y 的縮放數據
  getScaleAtY: (y) => {
    const currentRange = getPerspectiveX(y, canvas.width) - getPerspectiveX(y, 0);
    const baseRange = getPerspectiveX(bottomBoundaryY, canvas.width) - getPerspectiveX(bottomBoundaryY, 0);
    return { scale: (currentRange / baseRange), width: currentRange };
  },

  // 統一處理子彈狀態
 getBulletData: (b, isEnemy, isPVP) => {
  let bx, by;
  const vp = RICO_MATH.getVisualProgress(b.progress, isEnemy);
  
  // 消失點 Y 與 畫布底 Y
  const vY = vanishPoint.y;
  const bottomY = vanishPoint.y + RICO_MATH.ViewDeep; // 1.0 的位置

  if (isEnemy) {
    // 【修正】敵人射向玩家：從 0.2 飛向 1.2 (飛過玩家身後)
    const enemyLineY = vY + 0.2 * RICO_MATH.ViewDeep;
    const overPlayerY = vY + 1.2 * RICO_MATH.ViewDeep;
    by = enemyLineY + vp * (overPlayerY - enemyLineY);
  } else {
    // 【修正】玩家射向敵人：從 1.0 飛向 0 (飛向消失點)
    const startY = bottomY;
    const targetY = vY; 
    by = startY + vp * (targetY - startY);
  }

  // 保持固定的斜率軌跡
  const slope = (b.startX - vanishPoint.x) / (b.startY - vanishPoint.y);
  bx = vanishPoint.x + slope * (by - vanishPoint.y);

  // 安全邊界
  if (!isEnemy && by < vanishPoint.y) by = vanishPoint.y; 

  const s = RICO_MATH.getScaleAtY(by).scale;
  const bulletRadius = Math.max((basePlayerW / 10) * s, 0.1); 
  
  return { x: bx, y: by, scale: s, radius: bulletRadius };
}
};

// 輔助函式
function getPerspectiveX(y, baseX){ return vanishPoint.x + (baseX - vanishPoint.x) * ((y - vanishPoint.y) / RICO_MATH.ViewDeep); }

// --- 狀態獲取：整合 update 與 draw 共用數據 ---
function getCurrentGameState() {
  const state = {
    player: { x: player?.x, y: player?.y, hp: playerHP, facing: targetX > player?.x ? -1 : 1 },
    enemy: { x: 0, y: 0, w: 0, h: 0, hp: 0, label: "", color: "", isPVP: false, facing: 1, bullets: [] }
  };

  const enemyY = vanishPoint.y + (1/5) * RICO_MATH.ViewDeep;
  const eScale = RICO_MATH.getScaleAtY(enemyY);

  if (opponentId && otherPlayers[opponentId]) {
    const op = otherPlayers[opponentId];
    let remoteBullets = [];
    
    // 如果對手有最新的射擊記錄，根據時間差計算當前 progress
    if (op.lastShot) {
      const timeDiff = Date.now() - op.lastShot.timestamp;
      // 假設子彈飛完全程約需 1.5 秒 (根據原公式 speed 換算)
      const calculatedProgress = RICO_MATH.getTimeProgress(op.lastShot.timestamp); 
      if (calculatedProgress < 1) {
        remoteBullets.push({
          xRatio: op.lastShot.startXRatio,
          progress: calculatedProgress,
          timestamp: op.lastShot.timestamp // 傳遞時間戳
        });
      } 
    }

    state.enemy = {
      isPVP: true,
      x: RICO_MATH.getCanvasXByRatio(op.x, enemyY, true),
      y: enemyY,
      w: basePlayerW * eScale.scale,
      h: basePlayerH * eScale.scale,
      hp: op.hp !== undefined ? op.hp : maxHP, // 直接讀取對手同步過來的 HP
      label: "連線對手",
      color: "cyan",
      facing: opponentFacing, // <--- 改用這變數
      bullets: enemyBullets // <-- 改成這一行，確保 draw() 讀取正確的子彈陣列
    };
  } else if (enemy) {
    // AI 邏輯保持不變...
    state.enemy = {
      isPVP: false,
      x: enemy.x, y: enemy.y,
      w: basePlayerW * eScale.scale, h: basePlayerH * eScale.scale,
      hp: enemyHP, label: "AI 敵人", color: "white",
      facing: enemy.dir === 1 ? -1 : 1, bullets: enemyBullets
    };
  }
  return state;
}

// --- 初始化與 Canvas 管理 ---
function initGrid(){
  gridLines.length = 0;
  for(let i=0; i<30; i++){ gridLines.push({ x: (canvas.width/30)*i }); }
}

function resizeCanvas() {
  let oldW = canvas.width, oldH = canvas.height;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight * 0.9;
  let NewSizeWScale = canvas.width / oldW;
  let NewSizeHScale = canvas.height / oldH;
  basePlayerW = canvas.width / 9;
  basePlayerH = basePlayerW * (50/35);
  vanishPoint = { x: canvas.width/2, y: canvas.height*(31/48) };
  bottomBoundaryY = canvas.height;
  initGrid();
  if(player){ player.x *= NewSizeWScale; player.y *= NewSizeHScale; }
  if(enemy){ enemy.x *= NewSizeWScale; enemy.y *= NewSizeHScale; }
  if(bullets) bullets.forEach(b => { b.startX *= NewSizeWScale; b.startY *= NewSizeHScale; b.x *= NewSizeWScale; b.y *= NewSizeHScale; });
  if(enemyBullets) enemyBullets.forEach(b => { b.startX *= NewSizeWScale; b.startY *= NewSizeHScale; b.x *= NewSizeWScale; b.y *= NewSizeHScale; });
}

// --- 遊戲邏輯 ---
function update() {
  if (gameOver || !player) return;
  const game = getCurrentGameState();

  // --- 1. 玩家水平移動控制 ---
  let pLeftLimit = getPerspectiveX(player.y, 0) + basePlayerW / 2;
  let pRightLimit = getPerspectiveX(player.y, canvas.width) - basePlayerW / 2;
  let dx = targetX - player.x, mSpeed = canvas.width / 5 / 60;
  if (Math.abs(dx) > mSpeed) dx = mSpeed * Math.sign(dx);
  player.x = Math.max(pLeftLimit, Math.min(player.x + dx, pRightLimit));

  // --- 2. 玩家子彈更新與判定 ---
  bullets.forEach(b => {
    b.progress = RICO_MATH.getTimeProgress(b.timestamp);
    const d = RICO_MATH.getBulletData(b, false, false);
    b.x = d.x; b.y = d.y;

    // 擊中判定 (PVP 與 AI 共用邏輯)
    if (!b.hit && b.progress >= 0.75 && b.progress <= 0.92) {
      const xDist = Math.abs(b.x - game.enemy.x);
      if (xDist <= game.enemy.w / 2) {
        enemyHP--;
        b.hit = true;
        b.progress = 1; 
        hitSound.currentTime = 0; hitSound.play();
      }
    }
  });
  bullets = bullets.filter(b => b.progress < 1.0 && !b.hit);

  // --- 3. 敵人/對手子彈更新與判定 ---
  if (!game.enemy.isPVP && enemy) {
    updateAI(game.enemy.w); // AI 模式下的移動與發射邏輯
  }

  enemyBullets.forEach(eb => {
    eb.progress = RICO_MATH.getTimeProgress(eb.timestamp);
    const d = RICO_MATH.getBulletData(eb, true, game.enemy.isPVP);
    eb.x = d.x; eb.y = d.y;

    if (!eb.hit && eb.progress >= 0.75 && eb.progress <= 0.92) {
      const xDist = Math.abs(eb.x - player.x);
      if (xDist <= basePlayerW / 2) {
        eb.hit = true;
        eb.progress = 1;
        playerHP--;
        hitSound.currentTime = 0; hitSound.play();
        userRef.update({ hp: playerHP }); // 同步血量給對手看
      }
    }
  });
  enemyBullets = enemyBullets.filter(eb => eb.progress < 1.2 && !eb.hit);

  // --- 4. 遊戲結束處理 (含冷卻機制) ---
  if ((playerHP <= 0 || enemyHP <= 0) && !gameOver) {
    gameOver = true;
    isCoolingDown = true; // 啟動冷卻標誌，防止大廳立即點擊
    bgm.pause();
    (playerHP <= 0 ? failSound : winSound).play();

    // 延遲一段時間讓玩家看清結果，再執行重設
    setTimeout(async () => {
  stopLobbyListen(); 
  
  // 取得原本儲存的暱稱
  const savedName = localStorage.getItem("playerNickname") || "匿名玩家";

  // 1. 回歸 Firebase 初始狀態 (確保包含 name，避免變回 ID)
  await userRef.update({ 
    name: savedName,        // <--- 新增這行，確保暱稱被保留
    opponentId: null, 
    lastShot: null, 
    request: null,
    hp: maxHP 
  });

      // 2. 切換 UI
      lobbyUI.style.display = "block";
      lobbyStatus.textContent = "對戰結束，資料歸位中 (冷卻中)...";
      lobbyStatus.style.color = "yellow";

      // 3. 確保 Firebase 同步完成後的第二次延遲 (冷卻期)
      setTimeout(() => {
        isCoolingDown = false;
        lobbyStatus.textContent = "遊戲大廳";
        lobbyStatus.style.color = "white";
        startLobbyListen(); // 重新開啟大廳廣播監聽
      }, 3000); 

    }, 3500); 
  }
  
  syncToFirebase(); // 同步當前位置
}

function updateAI(enemyW) {
  const now = Date.now(), eScale = RICO_MATH.getScaleAtY(enemy.y);
  const danger = bullets.some(b => Math.abs(b.x - enemy.x) < 30 && b.y < enemy.y);
  if(danger && now - lastEnemyDodge > dodgeCooldown){ enemy.dir *= -1; lastEnemyDodge = now; }
  
  let enemySpeed = (canvas.width/5 / 60) * (eScale.width / (getPerspectiveX(bottomBoundaryY, canvas.width) - getPerspectiveX(bottomBoundaryY, 0)));
  enemy.x += enemy.dir * enemySpeed;
  if(enemy.x - enemyW/2 <= getPerspectiveX(enemy.y, 0)){ enemy.x = getPerspectiveX(enemy.y, 0) + enemyW/2; enemy.dir = 1; }
  if(enemy.x + enemyW/2 >= getPerspectiveX(enemy.y, canvas.width)){ enemy.x = getPerspectiveX(enemy.y, canvas.width) - enemyW/2; enemy.dir = -1; }

  if(now - lastEnemyShot > shotCooldown){
    let slope = (enemy.x - vanishPoint.x) / (enemy.y - vanishPoint.y);
    if(Math.abs((vanishPoint.x + slope * RICO_MATH.ViewDeep) - player.x) < 30){
      lastEnemyShot = now; 
	  enemyBullets.push({ startX: enemy.x, startY: enemy.y, x: enemy.x, y: enemy.y, progress: 0, timestamp: now });
    }
  }

  // 確保 AI 子彈也使用 getTimeProgress 且不被 Math.min 限制
  enemyBullets.forEach(b => {
    b.progress = RICO_MATH.getTimeProgress(b.timestamp);
  });
  // 這裡不需要任何 filter，統一由 update() 函式的 filter 處理
}

// --- 繪製 ---
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, "skyblue"); 
  grad.addColorStop(1, "white");
  ctx.fillStyle = grad; 
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

  if (showGrid) {
    ctx.strokeStyle = "gray";
    gridLines.forEach(line => { 
      ctx.beginPath(); ctx.moveTo(line.x, bottomBoundaryY); ctx.lineTo(vanishPoint.x, vanishPoint.y); ctx.stroke(); 
    });
    ctx.beginPath(); ctx.moveTo(0, bottomBoundaryY); ctx.lineTo(canvas.width, bottomBoundaryY); ctx.stroke();
  }

  if (!player) return;
  const game = getCurrentGameState();

  if (gameOver) {
    ctx.fillStyle = "yellow"; 
    ctx.font = "bold 40px Arial"; 
    ctx.textAlign = "center";
    ctx.shadowBlur = 10;
    ctx.shadowColor = "black";

    let winText = "";
    if (opponentId) {
      // 從 otherPlayers 緩存中讀取最新名字
      const opName = otherPlayers[opponentId]?.name || "對手";
      const myName = otherPlayers[playerId]?.name || "我";
      winText = (playerHP <= 0) ? `勝利者: ${opName}` : `勝利者: ${myName}`;
    } else {
      winText = (playerHP <= 0) ? "AI 敵人勝利!" : "玩家勝利!";
    }

    ctx.fillText(winText, canvas.width / 2, canvas.height / 2);
    ctx.shadowBlur = 0;

    if (playerHP <= 0) { 
      ctx.save(); 
      let fDir = game.player.facing;
      ctx.scale(fDir, 1); 
      ctx.drawImage(failImg, fDir * game.player.x - basePlayerW, game.player.y - basePlayerH / 1.3, basePlayerW * 1.7, basePlayerH / 1.3); 
      ctx.restore();
    }
    return;
  }

  // 畫對手/AI
  ctx.save(); 
  ctx.translate(game.enemy.x, game.enemy.y); 
  ctx.scale(game.enemy.facing, 1);
  ctx.drawImage(enemyImg, -game.enemy.w / 2, -game.enemy.h, game.enemy.w, game.enemy.h); 
  ctx.restore();

  // --- 修正：更精確的暱稱標籤抓取 ---
  ctx.fillStyle = game.enemy.color; 
  ctx.font = "bold 16px Arial"; 
  ctx.textAlign = "center";
  const labelName = (opponentId && otherPlayers[opponentId]?.name) ? otherPlayers[opponentId].name : game.enemy.label;
  ctx.fillText(labelName, game.enemy.x, game.enemy.y - game.enemy.h - 25);
  
  drawHPAbove(game.enemy.x, game.enemy.y, game.enemy.hp, maxHP, game.enemy.w, game.enemy.h, true);

  // 畫敵人子彈
  game.enemy.bullets.forEach(b => {
    if (b.hit) return; 
    const d = RICO_MATH.getBulletData(b, true, game.enemy.isPVP); 
    ctx.beginPath(); ctx.fillStyle = "orange"; ctx.arc(d.x, d.y, d.radius, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; ctx.lineWidth = 2 * d.scale; ctx.stroke();
  });

  // 畫玩家子彈
  bullets.forEach(b => {
    if (b.hit) return; 
    let drawX, drawY, drawRadius;
    const d = RICO_MATH.getBulletData(b, false, false);
    if (b.progress <= 1.0) {
      drawX = d.x; drawY = d.y; drawRadius = d.radius;
    } else {
      const extP = (b.progress - 1.0) / 0.2; 
      const enemyLineY = vanishPoint.y + Y_END * RICO_MATH.ViewDeep;
      drawY = enemyLineY + extP * (vanishPoint.y - enemyLineY);
      drawX = d.x + extP * (vanishPoint.x - d.x);
      drawRadius = Math.max(d.radius * (1 - extP), 1.5);
    }
    ctx.beginPath(); ctx.fillStyle = "yellow"; ctx.arc(drawX, drawY, drawRadius, 0, Math.PI * 2); ctx.fill();
  });

  // 畫玩家
  ctx.save(); 
  ctx.scale(game.player.facing, 1);
  ctx.drawImage(playerImg, game.player.facing * game.player.x - basePlayerW / 2, game.player.y - basePlayerH, basePlayerW, basePlayerH);
  ctx.restore();
  drawHPAbove(game.player.x, game.player.y, game.player.hp, maxHP, basePlayerW, basePlayerH, false);
}

// --- 輔助邏輯與事件 ---
function syncToFirebase() {
  const now = Date.now();
  if (!opponentId || gameOver || !player) return;
  if (now - lastFirebaseUpdateTime < FIREBASE_TICK_RATE) return;
  
  lastFirebaseUpdateTime = now;
  // 僅同步 X 座標比例，大幅降低封包大小
  userRef.update({ 
    x: player.x / canvas.width
  });
}

function drawHPAbove(x, y, hp, max, w, h, isE){
  if(hp >= max) return;
  ctx.save(); ctx.globalAlpha = 0.7;
  let bh = isE ? Math.max(6, 10*(h/basePlayerH)) : 10;
  ctx.fillStyle = "gray"; ctx.fillRect(x - w/2, y - h - 10, w, bh);
  let color = "green"; if(hp<=3) color="yellow"; if(hp<=2) color="red";
  if(hp===1 && Math.floor(Date.now()/300)%2===0) color="rgba(255,0,0,0)";
  ctx.fillStyle = color; ctx.fillRect(x - w/2, y - h - 10, w*(hp/max), bh); ctx.restore();
}

function initGame(){
  vanishPoint = { x: canvas.width/2, y: canvas.height*(31/48) }; 
  bottomBoundaryY = canvas.height;
  player = { x: canvas.width/2, y: bottomBoundaryY };
  enemy = { x: vanishPoint.x, y: vanishPoint.y + (1/5) * (bottomBoundaryY - vanishPoint.y), dir: 1 };
  bullets = []; enemyBullets = []; playerHP = maxHP; enemyHP = maxHP; gameOver = false;
  toggleGridBtn.style.display = "block"; resizeCanvas();
  if (opponentId) {
    userRef.set({ x: player.x / canvas.width, hp: playerHP, bullets: [], opponentId: opponentId });
  }
}

let targetX = 0;
canvas.addEventListener("mousemove", e => { targetX = e.clientX - canvas.getBoundingClientRect().left; });
canvas.addEventListener("click", shootBullet);
canvas.addEventListener("touchstart", e => { e.preventDefault(); targetX = e.touches[0].clientX - canvas.getBoundingClientRect().left; shootBullet(); }, { passive: false });
canvas.addEventListener("touchmove", e => { e.preventDefault(); targetX = e.touches[0].clientX - canvas.getBoundingClientRect().left; }, { passive: false });

function shootBullet() {
  if(gameOver || !player || Date.now() - lastPlayerShot < shotCooldown) return;
  const now = Date.now();
  lastPlayerShot = now;

  const startX = player.x;
  const startY = player.y;
  
  // 本地顯示子彈
  bullets.push({ startX, startY, x: startX, y: startY, progress: 0, timestamp: now });
  shootSound.currentTime = 0; shootSound.play();

  // PVP 模式下，僅傳送發射瞬間的數據與時間戳
  if (opponentId) {
    db.ref(`users/${playerId}/lastShot`).update({
      startXRatio: startX / canvas.width,
      startY: startY,
      timestamp: now
    });
  }
}

function gameLoop() { update(); draw(); if(!gameOver) requestAnimationFrame(gameLoop); }

toggleGridBtn.addEventListener("click", () => { showGrid = !showGrid; toggleGridBtn.textContent = showGrid ? "隱藏格線" : "顯示格線"; });
playAIBtn.onclick = () => { 
  opponentId = null; 
  stopLobbyListen(); // <-- 插入這行：進入 AI 模式立即停止監聽
  lobbyUI.style.display = "none"; 
  initGame(); 
  bgm.play(); 
  gameLoop(); 
};

window.addEventListener("resize", resizeCanvas);
window.addEventListener("orientationchange", resizeCanvas);

// Firebase 監聽
function startLobbyListen() {
    db.ref("users").on("value", snapshot => {
        otherPlayers = snapshot.val() || {};
        const me = otherPlayers[playerId];
        
        // 更新大廳清單
        playerListDiv.innerHTML = "";
        Object.keys(otherPlayers).forEach(id => {
            if (id === playerId) return;
            const p = otherPlayers[id];
            const item = document.createElement("div");
            item.className = "player-item";
            
            // 根據狀態顯示不同的標籤
            let statusText = p.opponentId ? " (對戰中)" : " (在線)";
            if (isCoolingDown) statusText = " (對戰冷卻中)";
            
            item.textContent = (p.name || id) + statusText;

            // 只有雙方都不在冷卻且對方沒在對戰時才可點擊
            if (!p.opponentId && !isCoolingDown) {
    item.onclick = () => {
        // 1. 發送邀請到 Firebase
        db.ref(`users/${id}/request`).set({ 
            from: playerId, 
            fromName: me.name 
        });
        // 2. 移除 alert，直接進入等待開始狀態
        prepareForBattle(id); 
    };
}
            playerListDiv.appendChild(item);
        });

        // 處理接收端：收到挑戰
        if (me?.request && gameOver && !isCoolingDown) {
		  const requester = otherPlayers[me.request.from];
		  if (!requester || requester.opponentId) {
            userRef.update({ request: null });
            return;
          }
		  
		  
          if (confirm(`來自 ${me.request.fromName} 的挑戰？`)) {
          const targetId = me.request.from;
          userRef.update({ request: null, opponentId: targetId });
          db.ref(`users/${targetId}`).update({ opponentId: playerId });
          prepareForBattle(targetId);
        } else {
          // 對方拒絕時，清除請求。這會觸發發起者那邊的 checkRef 邏輯回到大廳
          userRef.update({ request: null, opponentId: null }); 
        }
}
    });
}

function prepareForBattle(targetId) {
    opponentId = targetId;
    lobbyStatus.textContent = "已發送邀請，等待對方接受...";
    lobbyStatus.style.color = "#00ff00";

    // 如果之前有殘留的定時器，先清除
    if (battleTimer) clearTimeout(battleTimer);

    const checkRef = db.ref(`users/${targetId}`);
    
    checkRef.on("value", (snapshot) => {
        const p = snapshot.val();
        
        if (p && p.opponentId === playerId) {
            checkRef.off("value");
            // 【關鍵】：對手接受了，立即清除逾時定時器
            if (battleTimer) {
                clearTimeout(battleTimer);
                battleTimer = null;
            }
            lobbyStatus.textContent = "對手已接受，準備開戰...";
            
            setTimeout(() => {
                enterPVPMode();
            }, 1000);
        }
        
        if (!p || (p.request === null && p.opponentId !== playerId)) {
            if (p && p.request === null && p.opponentId === null) {
                checkRef.off("value");
                // 【關鍵】：被拒絕時也清除定時器
                if (battleTimer) {
                    clearTimeout(battleTimer);
                    battleTimer = null;
                }
                alert("對方拒絕了你的挑戰或已離開");
                opponentId = null;
                lobbyStatus.textContent = "遊戲大廳";
                lobbyStatus.style.color = "white";
                startLobbyListen();
            }
        }
    });

    // 將定時器 ID 存入 battleTimer
    battleTimer = setTimeout(() => {
        checkRef.off("value");
        // 檢查是否還停留在大廳且目標還是同一個人
        if (lobbyUI.style.display !== "none" && opponentId === targetId) {
		    db.ref(`users/${targetId}/request`).set(null);
            alert("邀請逾時，無人回應");
            opponentId = null;
            lobbyStatus.textContent = "遊戲大廳";
            lobbyStatus.style.color = "white";
            startLobbyListen();
        }
        battleTimer = null; // 執行完畢後清空
    }, 15000);
}

function enterPVPMode() {
  if (battleTimer) {
      clearTimeout(battleTimer);
      battleTimer = null;
    }

  stopLobbyListen(); // 清理舊監聽

  let lastProcessedShotTime = 0;

  // --- 修正：確保自己有暱稱，否則對手畫面會看不到你的名字 ---
  const myCurrentData = otherPlayers[playerId];
  if (!myCurrentData || !myCurrentData.name) {
    const tempName = "玩家_" + playerId.substring(0, 4);
    userRef.update({ name: tempName });
  }

  // 1. 設定斷線自動清理：當我斷線時，通知對手我也離開了
  userRef.onDisconnect().remove();

  // 2. 開啟對手的精準監聽
  const opponentRef = db.ref(`users/${opponentId}`);
  opponentRef.on("value", (snapshot) => {
    const data = snapshot.val();
    
    if (data) {
      // 更新本地快取，確保 draw() 裡的暱稱標籤能抓到最新資料
      otherPlayers[opponentId] = data;

      // --- 更新對手動態 ---
      if (data.x !== undefined && data.x !== lastOpponentX) {
        opponentFacing = data.x > lastOpponentX ? 1 : -1;
        lastOpponentX = data.x;
      }

      // --- 處理同步子彈 ---
      if (data.lastShot && data.lastShot.timestamp > lastProcessedShotTime) {
        lastProcessedShotTime = data.lastShot.timestamp;
        const remoteX = RICO_MATH.getCanvasXByRatio(1 - data.lastShot.startXRatio, vanishPoint.y + 0.2 * RICO_MATH.ViewDeep);
        
        enemyBullets.push({
          startX: remoteX,
          startY: vanishPoint.y + 0.2 * RICO_MATH.ViewDeep,
          x: remoteX,
          y: vanishPoint.y + 0.2 * RICO_MATH.ViewDeep,
          progress: 0,
          timestamp: data.lastShot.timestamp,
          hit: false
        });
      }

      // --- 同步 HP ---
      if (data.hp !== undefined) {
        enemyHP = data.hp;
      }
	  
	  otherPlayers[opponentId] = data;
	  
    } else {
      // --- 重要：對手斷線處理 ---
      if (!gameOver) {
        gameOver = true;
        alert("對手已離開遊戲，正在回到大廳...");
        
        // 主動清除自己的戰鬥狀態
        userRef.update({ 
          opponentId: null, 
          hp: maxHP, 
          lastShot: null, 
          request: null 
        }).then(() => {
          location.reload(); 
        });
      }
    }
  });

  // 3. 進入遊戲畫面
  lobbyUI.style.display = "none";
  initGame(); 
  bgm.play(); 
  gameLoop();
}



function stopLobbyListen() {
  // 關閉大廳全體監聽
  db.ref("users").off("value");
  
  // 關閉對當前對手的所有監聽
  if (opponentId) {
    db.ref(`users/${opponentId}`).off("value");
  }
  
  // 建議額外清除可能存在的單一屬性監聽
  userRef.off("value"); 
}

resizeCanvas(); 
draw();
// 先檢查暱稱，確認綁定後再開啟大廳監聽
checkNickname().then(() => {
    startLobbyListen();
});

// 監控玩家動作
["mousemove", "mousedown", "touchstart", "keydown"].forEach(evt => {
  window.addEventListener(evt, resetIdleTimer, { passive: true });
});

// 初始啟動計時器
resetIdleTimer();


</script>
</body>
</html>