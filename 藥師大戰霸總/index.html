<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>透視射擊遊戲（雙人同步配對修正版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
      background: black;
      height: 100%;
    }
    canvas { 
      display: block; 
      margin: auto; 
      background: black; 
      touch-action: none;
    }
    #restartBtn, #toggleGridBtn {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 18px;
      background: #444;
      color: white;
      border: none;
      cursor: pointer;
    }
    #toggleGridBtn { display: none; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<button id="restartBtn">開始遊戲</button>
<button id="toggleGridBtn">顯示格線</button>

<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script> 
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
<script>
const firebaseConfig = {
    apiKey: "AIzaSyDsQKp4MbIZiI_K95S8vy4q_q9pfx1c3aw",
    authDomain: "my-shooting-game-68732.firebaseapp.com",
    projectId: "my-shooting-game-68732",
    storageBucket: "my-shooting-game-68732.firebasestorage.app",
    messagingSenderId: "212506441565",
    appId: "1:212506441565:web:8fe492bef5abd7be711ab4"
  };
const app = firebase.initializeApp(firebaseConfig);
const db = firebase.database();

const playerId = Math.random().toString(36).substr(2,9);

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const restartBtn = document.getElementById("restartBtn");
const toggleGridBtn = document.getElementById("toggleGridBtn");

let facingRight= 1;
let basePlayerW, basePlayerH;
let player, enemy, bullets, enemyBullets, vanishPoint, bottomBoundaryY, playerHP, enemyHP, gameOver;
let lastPlayerShot = 0, lastEnemyShot = 0, lastEnemyDodge = 0;
const shotCooldown = 500, dodgeCooldown = 200, maxHP = 5;

let otherPlayers = {};
let otherBullets = {};
let opponentId = null;

const RICO_MATH = {
  get ViewDeep() { 
    let RICO_BUF = bottomBoundaryY - vanishPoint.y; 
    if(RICO_BUF < 1) RICO_BUF = 1; 
    return RICO_BUF; 
  }
};

const playerImg = new Image(); playerImg.src = "玩家.png";
const enemyImg = new Image(); enemyImg.src = "敵人.png";
const bgImg = new Image(); bgImg.src = "背景.png";
const failImg = new Image(); failImg.src = "fail.png";

const bgm = new Audio("bgm.mp3"); bgm.loop = true; bgm.volume = 0.5;
const shootSound = new Audio("發射.mp3");
const hitSound = new Audio("被擊中.mp3");
const winSound = new Audio("win.mp3");
const failSound = new Audio("fail.mp3");

let showGrid = false;
toggleGridBtn.addEventListener("click", () => {
  showGrid = !showGrid;
  toggleGridBtn.textContent = showGrid ? "隱藏格線" : "顯示格線";
});

const gridLines = [];
function initGrid(){
  gridLines.length = 0;
  for(let i=0;i<30;i++){ let x = (canvas.width/30)*i; gridLines.push({x}); }
}

function resizeCanvas() {
  let oldW = canvas.width; let oldH = canvas.height;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight * 0.9;
  let NewSizeWScale = canvas.width / oldW;
  let NewSizeHScale = canvas.height / oldH;
  basePlayerW = canvas.width /9;
  basePlayerH = basePlayerW * (50/35);
  vanishPoint = { x: canvas.width/2, y: canvas.height*(31/48) };
  bottomBoundaryY = canvas.height;
  initGrid();
  if(player){ player.x *= NewSizeWScale; player.y *= NewSizeHScale; }
  if(enemy){ 
    enemy.x *= NewSizeWScale; enemy.y *= NewSizeHScale; 
    let enemyCalc = getEnemyScale(enemy.y); enemy.scale = enemyCalc.scale;  
  }
  if(bullets) bullets.forEach(b => { b.startX *= NewSizeWScale; b.startY *= NewSizeHScale; b.x *= NewSizeWScale; b.y *= NewSizeHScale; if(b.size) b.size *= NewSizeWScale; if(b.speed) b.speed *= NewSizeWScale; }); 
  if(enemyBullets) enemyBullets.forEach(b => { b.startX *= NewSizeWScale; b.startY *= NewSizeHScale; b.x *= NewSizeWScale; b.y *= NewSizeHScale; if(b.size) b.size *= NewSizeWScale; if(b.speed) b.speed *= NewSizeWScale; });
}
window.addEventListener("resize", resizeCanvas);
window.addEventListener("orientationchange", resizeCanvas);

function getPerspectiveX(y, baseX){ return vanishPoint.x + (baseX - vanishPoint.x) * ((y - vanishPoint.y) / RICO_MATH.ViewDeep); }
function getEnemyScale(y) {
  let eLeftX = getPerspectiveX(y, 0); let eRightX = getPerspectiveX(y, canvas.width);
  let enemyWidth = eRightX - eLeftX;
  let pLeftX = getPerspectiveX(bottomBoundaryY, 0); let pRightX = getPerspectiveX(bottomBoundaryY, canvas.width);
  let playerWidth = pRightX - pLeftX;
  return { scale: (enemyWidth / playerWidth), width: enemyWidth };
}
function getBulletScale(y) {
  let bLeftX = getPerspectiveX(y, 0); let bRightX = getPerspectiveX(y, canvas.width);
  let pLeftX = getPerspectiveX(bottomBoundaryY, 0); let pRightX = getPerspectiveX(bottomBoundaryY, canvas.width);
  return (bRightX - bLeftX) / (pRightX - pLeftX);
}

function initGame(){
  vanishPoint = { x: canvas.width/2, y: canvas.height*(31/48) }; 
  bottomBoundaryY = canvas.height;
  player = { x: canvas.width/2, y: bottomBoundaryY, hp: maxHP };
  let enemyY = vanishPoint.y + (1/5) * RICO_MATH.ViewDeep;
  let initScale = getEnemyScale(enemyY);
  enemy = { x: vanishPoint.x, y: enemyY, dir: 1, scale: initScale.scale };
  bullets = []; enemyBullets = [];
  playerHP = maxHP; enemyHP = maxHP;
  gameOver = false;
  toggleGridBtn.style.display = "block";
  restartBtn.style.display = "none";
  lastPlayerShot = 0; lastEnemyShot = 0; lastEnemyDodge = 0;
  resizeCanvas();
  db.ref("players/" + playerId).set({ x: player.x, y: player.y, hp: playerHP });
  db.ref("bullets/" + playerId).set([]);
}

const playerMaxSpeed = () => canvas.width/5 / 60;
let targetX = 0;
canvas.addEventListener("mousemove", e => { targetX = e.clientX - canvas.getBoundingClientRect().left; });
canvas.addEventListener("click", shootBullet);
canvas.addEventListener("touchstart", e => { e.preventDefault(); shootBullet(); }, { passive: false });
canvas.addEventListener("touchmove", e => { e.preventDefault(); targetX = e.touches[0].clientX - canvas.getBoundingClientRect().left; }, { passive: false });

function shootBullet() {
  if(gameOver || !player) return;
  let now = Date.now();
  if(now - lastPlayerShot < shotCooldown) return;
  lastPlayerShot = now;
  const bullet = { startX: player.x, startY: player.y - basePlayerH*0.5, x: player.x, y: player.y - basePlayerH*0.5, progress: 0 };
  bullets.push(bullet);
  shootSound.currentTime = 0; shootSound.play();
  db.ref("bullets/" + playerId).set(bullets);
}

// AI 邏輯
setInterval(() => {
  if(gameOver || !enemy || opponentId) return; 
  let now = Date.now();
  if(now - lastEnemyShot < shotCooldown) return;
  let danger = Array.isArray(bullets) && bullets.some(b => Math.abs(b.x - enemy.x) < 30 && b.y < enemy.y);
  if(danger && now - lastEnemyDodge > dodgeCooldown){ enemy.dir *= -1; lastEnemyDodge = now; return; }
  let slope = (enemy.x - vanishPoint.x) / (enemy.y - vanishPoint.y);
  let tX = vanishPoint.x + slope * RICO_MATH.ViewDeep;
  if(Math.abs(tX - player.x) < 30){
    lastEnemyShot = now;
    enemyBullets.push({ startX: enemy.x, startY: enemy.y, x: enemy.x, y: enemy.y, progress: 0 });
  }
}, 50);

function getPlayerBulletSpeed(y, startX, startY) {
  let slope = Math.abs((startX - vanishPoint.x) / (startY - vanishPoint.y));
  let factor = (y - vanishPoint.y) / (bottomBoundaryY - vanishPoint.y); 
  return 0.02 * factor * (1 + slope) + 0.001;
}
function getEnemyBulletSpeed(y, startX, startY) { 
  let slope = Math.abs((startX - vanishPoint.x) / (startY - vanishPoint.y)); 
  let factor = (y - vanishPoint.y) / (bottomBoundaryY - vanishPoint.y); 
  return 0.001 + 0.02 * factor * (1 + slope);
}

function update() {
  if(gameOver || !player) return;

  let pLeftX = getPerspectiveX(player.y, 0); let pRightX = getPerspectiveX(player.y, canvas.width);
  let dx = targetX - player.x;
  let mSpeed = playerMaxSpeed();
  if(Math.abs(dx) > mSpeed) dx = mSpeed * Math.sign(dx);
  player.x += dx;
  if(player.x - basePlayerW/2 < pLeftX) player.x = pLeftX + basePlayerW/2;
  if(player.x + basePlayerW/2 > pRightX) player.x = pRightX - basePlayerW/2;
 
  bullets.forEach(b => { b.progress += getPlayerBulletSpeed(b.y, b.startX, b.startY); b.x = (1-b.progress)*b.startX + b.progress*vanishPoint.x; b.y = (1-b.progress)*b.startY + b.progress*vanishPoint.y; });
  bullets = bullets.filter(b => b.progress < 1);

  // 實作：有對手就即時接手本地敵人
  let curE = { x: 0, y: 0, w: 0, isPVP: false };
  if(opponentId && otherPlayers[opponentId]) {
    let op = otherPlayers[opponentId];
    // PvP 模式：同步對手位置與血量
    curE = { x: canvas.width - op.x, y: op.y, w: basePlayerW * getEnemyScale(op.y).scale, isPVP: true };
    enemyHP = op.hp; 
    enemyBullets = []; // 清空 AI 子彈
  } else {
    // AI 模式
    let enemyCalc = getEnemyScale(enemy.y); enemy.scale = enemyCalc.scale;
    let enemyW = basePlayerW * enemy.scale;
    let enemySpeed = playerMaxSpeed() * (enemyCalc.width / (getPerspectiveX(bottomBoundaryY, canvas.width) - getPerspectiveX(bottomBoundaryY, 0)));
    enemy.x += enemy.dir * enemySpeed;
    if(enemy.x - enemyW/2 <= getPerspectiveX(enemy.y, 0)){ enemy.x = getPerspectiveX(enemy.y, 0) + enemyW/2; enemy.dir = 1; }
    if(enemy.x + enemyW/2 >= getPerspectiveX(enemy.y, canvas.width)){ enemy.x = getPerspectiveX(enemy.y, canvas.width) - enemyW/2; enemy.dir = -1; }

    enemyBullets.forEach(b => {
      b.progress += getEnemyBulletSpeed(b.y, b.startX, b.startY);
      let slope = (b.startX - vanishPoint.x) / (b.startY - vanishPoint.y);
      let tX = vanishPoint.x + slope * RICO_MATH.ViewDeep;
      b.x = (1-b.progress)*b.startX + b.progress*tX; b.y = (1-b.progress)*b.startY + b.progress*bottomBoundaryY;
    });
    enemyBullets = enemyBullets.filter(b => b.progress < 1);
    curE = { x: enemy.x, y: enemy.y, w: enemyW, isPVP: false };
  }

  bullets.forEach(b => {
    if(Math.sqrt((b.x-curE.x)**2 + (b.y-curE.y)**2) < curE.w/2) {
      if(!curE.isPVP) enemyHP--; // AI 模式下才本地扣血
      b.progress = 1; hitSound.currentTime = 0; hitSound.play();
    }
  });

  let activeEBullets = opponentId ? (otherBullets[opponentId] || []) : enemyBullets;
  activeEBullets.forEach(b => {
    let bx = opponentId ? (canvas.width - b.x) : b.x;
    if(Math.sqrt((bx-player.x)**2 + (b.y-player.y)**2) < basePlayerW/2) {
      playerHP--; b.progress = 1; hitSound.currentTime = 0; hitSound.play();
    }
  });

  if(playerHP <= 0 || (opponentId && enemyHP <= 0) || (!opponentId && enemyHP <= 0)){ 
    gameOver = true; restartBtn.textContent = "重新開始"; restartBtn.style.display = "block"; bgm.pause();
    if(playerHP <= 0) failSound.play(); else winSound.play();
  }

  db.ref("players/" + playerId).update({ x: player.x, y: player.y, hp: playerHP });
  db.ref("bullets/" + playerId).set(bullets);
}

function drawHPAbove(x, y, hp, maxHP, charWidth, charHeight, isEnemy=false){
  if(hp >= maxHP) return;
  ctx.save(); ctx.globalAlpha = 0.7;
  let barHeight = isEnemy ? Math.max(6, 10 * (charHeight/basePlayerH)) : 10;
  ctx.fillStyle = "gray"; ctx.fillRect(x - charWidth/2, y - charHeight - 10, charWidth, barHeight);
  let color = "green";
  if(hp <= 3) color = "yellow";
  if(hp <= 2) color = "red";
  if(hp === 1 && Math.floor(Date.now()/300) % 2 === 0) color = "rgba(255,0,0,0)";
  ctx.fillStyle = color; ctx.fillRect(x - charWidth/2, y - charHeight - 10, charWidth * (hp/maxHP), barHeight);
  ctx.restore();
}

function drawGrid() {
  ctx.strokeStyle = "gray";
  gridLines.forEach(line => { ctx.beginPath(); ctx.moveTo(line.x, bottomBoundaryY); ctx.lineTo(vanishPoint.x, vanishPoint.y); ctx.stroke(); });
  ctx.beginPath(); ctx.moveTo(0, bottomBoundaryY); ctx.lineTo(canvas.width, bottomBoundaryY); ctx.stroke();
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  let gradient = ctx.createLinearGradient(0,0,0,canvas.height);
  gradient.addColorStop(0,"skyblue"); gradient.addColorStop(1,"white");
  ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
  if(showGrid){ drawGrid(); }

  if(!player) return;

  if(gameOver){
    ctx.fillStyle = "yellow"; ctx.font = "40px Arial"; ctx.textAlign = "center";
    ctx.fillText(playerHP <= 0 ? "敵人勝利!" : "玩家勝利!", canvas.width/2, canvas.height/2);
    if(playerHP <= 0){ 
      ctx.save(); if(targetX > player.x) facingRight = -1; else if(targetX < player.x) facingRight = 1;
      ctx.scale(facingRight,1); ctx.drawImage(failImg, facingRight*player.x- basePlayerW, player.y - basePlayerH/1.3, basePlayerW*1.7, basePlayerH/1.3); ctx.restore();
    }
    return;
  }

  let eX, eY, eHP, eLabel, eColor;
  if(opponentId && otherPlayers[opponentId]) {
    let op = otherPlayers[opponentId]; eX = canvas.width - op.x; eY = op.y; eHP = op.hp; eLabel = "連線對手"; eColor = "cyan";
  } else {
    eX = enemy.x; eY = enemy.y; eHP = enemyHP; eLabel = "AI 敵人"; eColor = "white";
  }

  let eS = getEnemyScale(eY).scale; let eW = basePlayerW * eS; let eH = basePlayerH * eS;
  ctx.drawImage(enemyImg, eX - eW/2, eY - eH, eW, eH);
  ctx.fillStyle = eColor; ctx.font = "bold 16px Arial"; ctx.textAlign = "center";
  ctx.fillText(eLabel, eX, eY - eH - 25);
  drawHPAbove(eX, eY, eHP, maxHP, eW, eH, true);

  ctx.fillStyle = "orange";
  let activeEBullets = opponentId ? (otherBullets[opponentId] || []) : enemyBullets;
  activeEBullets.forEach(b => {
    let bx = opponentId ? (canvas.width - b.x) : b.x;
    ctx.beginPath(); ctx.arc(bx, b.y, (basePlayerW/8)*getBulletScale(b.y), 0, Math.PI*2); ctx.fill();
  });

  ctx.fillStyle = "yellow";
  bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, (basePlayerW/8)*getBulletScale(b.y), 0, Math.PI*2); ctx.fill(); });

  ctx.save(); if(targetX > player.x) facingRight = -1; else if(targetX < player.x) facingRight = 1;
  ctx.scale(facingRight,1); ctx.drawImage(playerImg, facingRight*player.x- basePlayerW/2, player.y - basePlayerH, basePlayerW, basePlayerH);
  ctx.restore();
  drawHPAbove(player.x, player.y, playerHP, maxHP, basePlayerW, basePlayerH, false);
}

function gameLoop() { update(); draw(); if(!gameOver) requestAnimationFrame(gameLoop); }

restartBtn.addEventListener("click", () => { initGame(); bgm.play(); gameLoop(); });

// 實作：移除遊戲結束判定，隨時配對
db.ref("players").on("value", snapshot => { 
    otherPlayers = snapshot.val() || {}; 
    const sortedIds = Object.keys(otherPlayers).sort();
    const myIndex = sortedIds.indexOf(playerId);
    
    if (myIndex !== -1) {
        const pairIndex = (myIndex % 2 === 0) ? myIndex + 1 : myIndex - 1;
        opponentId = sortedIds[pairIndex] || null;
    } else {
        opponentId = null;
    }

    // 即時更新按鈕提示
    if (opponentId) {
        restartBtn.textContent = "對手已就緒";
        restartBtn.style.background = "#28a745"; 
    } else {
        restartBtn.textContent = "等待對手中...";
        restartBtn.style.background = "#444";
    }
});

db.ref("bullets").on("value", snapshot => { 
    otherBullets = snapshot.val() || {}; 
});

window.addEventListener("beforeunload", () => {
    db.ref("players/" + playerId).remove();
    db.ref("bullets/" + playerId).remove();
});

resizeCanvas(); 
draw(); 
</script>
</body>
</html>