<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ÂõõÂ∑ùÈ∫ªÂ∞áÊ∂àÊ∂àÊ®Ç</title>
<style>
  :root { 
    --tile-width: 48px;
    --tile-height: 72px;
    --gap: 8px; 
  }
  html, body {
    width: 100%; height: 100%; margin: 0; overflow: hidden;
    background:#0f172a; color:#e2e8f0; font-family: ui-sans-serif, system-ui;
    display:flex; flex-direction:column; align-items:center;
  }
  header { display:flex; gap:10px; align-items:center; margin-top:16px; }
  h1 { font-size:18px; margin:0; font-weight:600; }
  button {
    background:#334155; color:#e2e8f0; border:1px solid #475569; border-radius:8px; padding:8px 12px; cursor:pointer;
  }
  button:hover { background:#1f2937; }
  #board {
    position:relative; margin-top:16px; background:#111827; border:1px solid #374151; border-radius:12px;
    padding:40px;
    width:calc(var(--tile-width)*6 + var(--gap)*5 + 80px);
    height:calc(var(--tile-height)*6 + var(--gap)*5 + 80px);
    margin-left:auto; margin-right:auto;
    transform-origin: top left;
  }
  .tile {
    position:absolute; width:var(--tile-width); height:var(--tile-height);
    background:#f8fafc; border:2px solid #cbd5e1; border-radius:6px;
    display:flex; align-items:center; justify-content:center;
    cursor:pointer;
    box-shadow:0 6px 12px rgba(0,0,0,.35);
    transition:transform .12s ease, opacity .2s ease;
    overflow:hidden;
  }
  .tile img { width:100%; height:100%; object-fit:contain; }
  .tile.selected { outline:3px solid #22d3ee; transform:translateY(-2px) scale(1.03); }
  .tile.removing { animation:pop .22s ease forwards; }
  @keyframes pop { to { opacity:0; transform:scale(0.5); } }
  canvas { position:absolute; top:0; left:0; pointer-events:none; z-index:10; }
  #message { margin-top:12px; font-size:16px; font-weight:600; color:#22d3ee; }
  #timer { margin-left:10px; font-size:16px; font-weight:600; color:#facc15; }
  #winMessage {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(15,23,42,0.9);
    color: #facc15;
    font-size: 24px;
    font-weight: bold;
    padding: 20px 40px;
    border-radius: 12px;
    display: none;
    z-index: 1000;
  }
  .confetti {
    position: fixed;
    width: 10px; height: 10px;
    background: red;
    animation: fall linear forwards;
    z-index: 999;
  }
  @keyframes fall {
    to { transform: translateY(100vh) rotate(720deg); opacity: 0; }
  }
</style>
</head>
<body>
<header>
  <h1>ÂõõÂ∑ùÈ∫ªÂ∞áÊ∂àÊ∂àÊ®Ç</h1>
  <button onclick="resetGame()">ÈáçÊñ∞ÈñãÂßã</button>
  <button onclick="hint()">ÊèêÁ§∫</button>
  <span id="timer">0 Áßí</span>
</header>
<div id="board">
  <canvas id="pathCanvas"></canvas>
</div>
<div id="message"></div>
<div id="winMessage"></div>

<script>
const boardSize = 6;
const board = document.getElementById("board");
const canvas = document.getElementById("pathCanvas");
const ctx = canvas.getContext("2d");
const message = document.getElementById("message");

let timer = null;
let elapsedTime = 0;

function startTimer() {
  elapsedTime = 0;
  if (timer) clearInterval(timer);
  timer = setInterval(() => {
    elapsedTime++;
    document.getElementById("timer").innerText = elapsedTime + " Áßí";
  }, 1000);
}
function stopTimer() {
  if (timer) {
    clearInterval(timer);
    timer = null;
  }
}

function resizeCanvas(){
  canvas.width = board.offsetWidth;
  canvas.height = board.offsetHeight;
}
resizeCanvas();

function resizeBoard() {
  const scaleX = window.innerWidth / board.offsetWidth;
  const scaleY = window.innerHeight / board.offsetHeight;
  const scale = Math.min(scaleX, scaleY);
  board.style.transform = `scale(${scale})`;
  resizeCanvas();
}
window.addEventListener("resize", resizeBoard);
resizeBoard();

let tiles = [];
let selected = [];

const symbols = [
  "images/tile1.png","images/tile2.png","images/tile3.png","images/tile4.png",
  "images/tile5.png","images/tile6.png","images/tile7.png","images/tile8.png",
  "images/tile9.png","images/tile10.png","images/tile11.png","images/tile12.png"
];

function initBoard() {
  board.querySelectorAll(".tile").forEach(t => t.remove());
  tiles = [];
  message.textContent = "";
  let pool = [];
  for (let i=0;i<boardSize*boardSize/2;i++) {
    let s = symbols[i % symbols.length];
    pool.push(s,s);
  }
  pool.sort(()=>Math.random()-0.5);

  const style = getComputedStyle(board);
  const tileW=parseInt(style.getPropertyValue('--tile-width'));
  const tileH=parseInt(style.getPropertyValue('--tile-height'));
  const gap=parseInt(style.getPropertyValue('--gap'));
  const boardW = board.offsetWidth;
  const boardH = board.offsetHeight;
  const totalTilesW = boardSize * tileW + (boardSize-1)*gap;
  const totalTilesH = boardSize * tileH + (boardSize-1)*gap;
  const offsetX = (boardW - totalTilesW) / 2;
  const offsetY = (boardH - totalTilesH) / 2;

  for (let r=0;r<boardSize;r++) {
    tiles[r] = [];
    for (let c=0;c<boardSize;c++) {
      const tile = document.createElement("div");
      tile.className="tile";
      const img = document.createElement("img");
      img.src = pool[r*boardSize+c];
      tile.appendChild(img);
      tile.dataset.symbol = pool[r*boardSize+c];
      tile.style.left = `${c*(tileW+gap)+offsetX}px`;
      tile.style.top = `${r*(tileH+gap)+offsetY}px`;
      board.appendChild(tile);
      tiles[r][c]=tile;
      tile.addEventListener("click",()=>selectTile(r,c));
      tile.addEventListener("touchstart",(e)=>{
        e.preventDefault();
        const {x,y} = getScaledCoords(e);
        handleTouch(x,y);
      });
    }
  }
  startTimer(); // Êñ∞Â±ÄÈñãÂßãË®àÊôÇ
}

function getScaledCoords(event) {
  const rect = board.getBoundingClientRect();
  const scaleX = board.offsetWidth / rect.width;
  const scaleY = board.offsetHeight / rect.height;
  const clientX = event.touches ? event.touches[0].clientX : event.clientX;
  const clientY = event.touches ? event.touches[0].clientY : event.clientY;
  const x = (clientX - rect.left) * scaleX;
  const y = (clientY - rect.top) * scaleY;
  return { x, y };
}

function handleTouch(x,y){
  const style = getComputedStyle(board);
  const tileW=parseInt(style.getPropertyValue('--tile-width'));
  const tileH=parseInt(style.getPropertyValue('--tile-height'));
  const gap=parseInt(style.getPropertyValue('--gap'));
  const boardW = board.offsetWidth;
  const boardH = board.offsetHeight;
  const totalTilesW = boardSize * tileW + (boardSize-1)*gap;
  const totalTilesH = boardSize * tileH + (boardSize-1)*gap;
  const offsetX = (boardW - totalTilesW) / 2;
  const offsetY = (boardH - totalTilesH) / 2;
  const c = Math.floor((x - offsetX) / (tileW+gap));
  const r = Math.floor((y - offsetY) / (tileH+gap));
  if(r>=0 && r<boardSize && c>=0 && c<boardSize){
    selectTile(r,c);
  }
}

function selectTile(r,c){
  const tile = tiles[r][c];
  if(!tile) return;
  if(selected.length===0){
    tile.classList.add("selected");
    selected.push({r,c,tile});
  } else if(selected.length===1){
    const first=selected[0];
    if(first.tile===tile){ return; }
    tile.classList.add("selected");
    selected.push({r,c,tile});
    tryMatch();
  }
}

function tryMatch(){
  const [a,b]=selected;
  if(a.tile.dataset.symbol===b.tile.dataset.symbol){
    const path=findPath(a.r,a.c,b.r,b.c);
    if(path){
      drawPath(path);
      setTimeout(()=>{
        a.tile.classList.add("removing");
        b.tile.classList.add("removing");
        a.tile.addEventListener("animationend",()=>a.tile.remove());
        b.tile.addEventListener("animationend",()=>b.tile.remove());
        tiles[a.r][a.c]=null; 
        tiles[b.r][b.c]=null;
        clearSelection();
        clearCanvas();
        checkWin();
        // üîπ Ê∂àÈô§ÂæåÊ™¢Êü•ÊòØÂê¶ÊúâËß£ÔºåËã•ÁÑ°Ëß£ÂâáÂè™Ê¥óÂâ©‰∏ãÁöÑÁâå
        setTimeout(()=>{
          if(!hasSolution()){
            message.textContent = "‚ö° ÁÑ°Ëß£ÔºåËá™ÂãïÊ¥óÁâåÔºÅ";
            shuffleRemainingTiles();
          }
        },400);
      },300);
      return;
    }
  }
  setTimeout(clearSelection,300);
}

function clearSelection(){
  selected.forEach(s=>s.tile.classList.remove("selected"));
  selected=[];
}

function clearCanvas(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
}

function drawPath(path){
  clearCanvas();
  ctx.beginPath();
  ctx.moveTo(path[0].x,path[0].y);
  for(let i=1;i<path.length;i++){
    ctx.lineTo(path[i].x,path[i].y);
  }
  ctx.strokeStyle="#22d3ee";
  ctx.lineWidth=3;
  ctx.stroke();
}

function isEmptyCell(r, c) {
  if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) return true;
  return tiles[r][c] === null;
}

function findPath(r1, c1, r2, c2) {
  const dirs = [[1,0],[0,1],[-1,0],[0,-1]];
  const queue = [{ r: r1, c: c1, path: [center(r1, c1)], turns: 0, dir: null }];
  const visited = new Set();

  while (queue.length) {
    const { r, c, path, turns, dir } = queue.shift();
    if (r === r2 && c === c2) {
      return [...path, center(r2, c2)];
    }
    for (const [dr, dc] of dirs) {
      let nr = r + dr, nc = c + dc;
      let newTurns = (dir === null || (dir[0] === dr && dir[1] === dc)) ? turns : turns + 1;
      if (newTurns > 2) continue;
      while (nr >= -1 && nr <= boardSize && nc >= -1 && nc <= boardSize) {
        if (!(nr === r2 && nc === c2)) {
          if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
            if (!isEmptyCell(nr, nc)) break;
          }
        }
        const key = `${nr},${nc},${dr},${dc},${newTurns}`;
        if (!visited.has(key)) {
          visited.add(key);
          queue.push({
            r: nr, c: nc,
            path: [...path, center(nr, nc)],
            turns: newTurns,
            dir: [dr, dc]
          });
        }
        if (nr === r2 && nc === c2) break;
        nr += dr; nc += dc;
      }
    }
  }
  return null;
}

function center(r,c){
  const style = getComputedStyle(board);
  const tileW=parseInt(style.getPropertyValue('--tile-width'));
  const tileH=parseInt(style.getPropertyValue('--tile-height'));
  const gap=parseInt(style.getPropertyValue('--gap'));
  const boardW = board.offsetWidth;
  const boardH = board.offsetHeight;
  const totalTilesW = boardSize * tileW + (boardSize-1)*gap;
  const totalTilesH = boardSize * tileH + (boardSize-1)*gap;
  const offsetX = (boardW - totalTilesW) / 2;
  const offsetY = (boardH - totalTilesH) / 2;
  const x=c*(tileW+gap)+offsetX+tileW/2;
  const y=r*(tileH+gap)+offsetY+tileH/2;
  return {x,y};
}

function checkWin(){
  if(tiles.flat().every(t => t===null)){
    stopTimer(); // üîπ ÈÅéÈóúÂÅúÊ≠¢Ë®àÊôÇ
    const winMessage = document.getElementById("winMessage");
    winMessage.textContent = "üéâ ÊÅ≠ÂñúÈÅéÈóúÔºåËÄóÊôÇ " + elapsedTime + " Áßí";
    winMessage.style.display = "block";
    launchConfetti();
    setTimeout(()=>{
      winMessage.style.display = "none";
    },3000);
    // üîπ ‰∏çÂÜçËá™ÂãïÈáçÁΩÆÔºåÁ≠âÂæÖ‰ΩøÁî®ËÄÖÊåâ‰∏ã„ÄåÈáçÊñ∞ÈñãÂßã„Äç
  }
}

function hint(){
  clearSelection();
  clearCanvas();
  for(let r1=0;r1<boardSize;r1++){
    for(let c1=0;c1<boardSize;c1++){
      let t1=tiles[r1][c1];
      if(!t1) continue;
      for(let r2=r1;r2<boardSize;r2++){
        for(let c2=0;c2<boardSize;c2++){
          let t2=tiles[r2][c2];
          if(!t2 || (r1===r2 && c1===c2)) continue;
          if(t1.dataset.symbol===t2.dataset.symbol){
            let path=findPath(r1,c1,r2,c2);
            if(path){
              t1.classList.add("selected");
              t2.classList.add("selected");
              drawPath(path);
              return;
            }
          }
        }
      }
    }
  }
}

function hasSolution(){
  for(let r1=0;r1<boardSize;r1++){
    for(let c1=0;c1<boardSize;c1++){
      let t1=tiles[r1][c1];
      if(!t1) continue;
      for(let r2=r1;r2<boardSize;r2++){
        for(let c2=0;c2<boardSize;c2++){
          let t2=tiles[r2][c2];
          if(!t2 || (r1===r2 && c1===c2)) continue;
          if(t1.dataset.symbol===t2.dataset.symbol){
            if(findPath(r1,c1,r2,c2)) return true;
          }
        }
      }
    }
  }
  return false;
}

// üîπ Âè™Ê¥óÂâ©‰∏ãÁöÑÁâå
function shuffleRemainingTiles(){
  let remaining = [];
  for(let r=0;r<boardSize;r++){
    for(let c=0;c<boardSize;c++){
      if(tiles[r][c]){
        remaining.push(tiles[r][c].dataset.symbol);
      }
    }
  }
  remaining.sort(()=>Math.random()-0.5);
  let index=0;
  for(let r=0;r<boardSize;r++){
    for(let c=0;c<boardSize;c++){
      if(tiles[r][c]){
        tiles[r][c].dataset.symbol = remaining[index];
        tiles[r][c].querySelector("img").src = remaining[index];
        index++;
      }
    }
  }
}

function resetGame(){
  stopTimer(); // üîπ ÂÅúÊ≠¢Ë®àÊôÇ
  clearCanvas();
  clearSelection();
  initBoard(); // üîπ ÈáçÊñ∞ÈñãÂßã‰∏¶ÈáçÊñ∞Ë®àÊôÇ
}

function launchConfetti(){
  for(let i=0;i<80;i++){
    const confetti = document.createElement("div");
    confetti.className = "confetti";
    confetti.style.left = Math.random()*window.innerWidth + "px";
    confetti.style.background = randomColor();
    confetti.style.width = 8 + Math.random()*8 + "px";
    confetti.style.height = 8 + Math.random()*8 + "px";
    confetti.style.opacity = 0.8;
    confetti.style.transform = `rotate(${Math.random()*360}deg)`;
    confetti.style.animationDuration = (2 + Math.random()*2) + "s"; // Èö®Ê©üÈÄüÂ∫¶
    document.body.appendChild(confetti);
    setTimeout(()=>confetti.remove(),4000);
  }
}

function randomColor(){
  const colors = ["#f87171","#facc15","#34d399","#60a5fa","#a78bfa","#f472b6"];
  return colors[Math.floor(Math.random()*colors.length)];
}

initBoard();
</script>
</body>
</html>
