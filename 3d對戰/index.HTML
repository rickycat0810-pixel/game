<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>透視射擊遊戲</title>
  <style>
    canvas { background: black; display: block; margin: auto; }
    #restartBtn {
      display: none;
      margin: 20px auto;
      padding: 10px 20px;
      font-size: 18px;
      background: #444;
      color: white;
      border: none;
      cursor: pointer;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<button id="restartBtn">重新開始</button>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const restartBtn = document.getElementById("restartBtn");

// 載入圖片
const playerImg = new Image();
playerImg.src = "玩家.png";
const enemyImg = new Image();
enemyImg.src = "敵人.png";
const bgImg = new Image();
bgImg.src = "背景.png";

// 可調整倍率
const scaleFactor = 2.0;
const basePlayerW = 35 * scaleFactor;
const basePlayerH = 50 * scaleFactor;

let player, enemy, bullets, enemyBullets, vanishPoint, bottomBoundaryY, playerHP, enemyHP, gameOver;
let lastPlayerShot = 0;
let lastEnemyShot = 0;
let lastEnemyDodge = 0;
const shotCooldown = 500;
const dodgeCooldown = 200;
const maxHP = 5;

// 抽象化透視公式
function getPerspectiveX(y, baseX){
  return vanishPoint.x + (baseX - vanishPoint.x) * ((y - vanishPoint.y) / (bottomBoundaryY - vanishPoint.y));
}

function initGame(){
  vanishPoint = { x: canvas.width/2, y: (canvas.height * (4/9))-10 }; 
  bottomBoundaryY = canvas.height * (2/3);

  // 玩家位置：貼齊底端透視邊界
  player = { x: canvas.width/2, y: bottomBoundaryY };

  // 計算敵人縮放比例
  let pLeftX = getPerspectiveX(player.y, 0);
  let pRightX = getPerspectiveX(player.y, canvas.width);
  let playerWidth = pRightX - pLeftX;

  let eLeftX = getPerspectiveX(vanishPoint.y, 0);
  let eRightX = getPerspectiveX(vanishPoint.y, canvas.width);
  let enemyWidth = eRightX - eLeftX;

  let enemyScale = (enemyWidth / playerWidth)*1.2;

  // 固定 y 在消失點 +40
  enemy = { x: vanishPoint.x, y: vanishPoint.y + 30, dir: 1, scale: enemyScale };

  bullets = [];
  enemyBullets = [];
  playerHP = maxHP;
  enemyHP = maxHP;
  gameOver = false;
  restartBtn.style.display = "none";
  lastPlayerShot = 0;
  lastEnemyShot = 0;
  lastEnemyDodge = 0;
}

initGame();

const playerMaxSpeed = canvas.width/5 / 60;
let targetX = player.x;

// 玩家移動
canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  targetX = e.clientX - rect.left;
});

// 玩家射擊
canvas.addEventListener("click", () => {
  if(gameOver) return;
  let now = Date.now();
  if(now - lastPlayerShot < shotCooldown) return;
  lastPlayerShot = now;
  bullets.push({ startX: player.x, startY: player.y, x: player.x, y: player.y, progress: 0 });
});

// 敵人射擊邏輯
setInterval(() => {
  if(gameOver) return;
  let now = Date.now();
  if(now - lastEnemyShot < shotCooldown) return;

  let danger = bullets.some(b => Math.abs(b.x - enemy.x) < 30 && b.y < enemy.y);
  if(danger && now - lastEnemyDodge > dodgeCooldown){ 
    enemy.dir *= -1; 
    lastEnemyDodge = now;
    return; 
  }

  let slope = (enemy.x - vanishPoint.x) / (enemy.y - vanishPoint.y);
  let targetX = vanishPoint.x + slope * (bottomBoundaryY - vanishPoint.y);
  if(Math.abs(targetX - player.x) < 30){
    lastEnemyShot = now;
    enemyBullets.push({ startX: enemy.x, startY: enemy.y, x: enemy.x, y: enemy.y, progress: 0 });
  }
}, 50);

// 更新邏輯
function update() {
  if(gameOver) return;

  let dx = targetX - player.x;
  if(Math.abs(dx) > playerMaxSpeed) dx = playerMaxSpeed * Math.sign(dx);
  player.x += dx;

  // 玩家邊界限制
  let pLeftX = getPerspectiveX(player.y, 0);
  let pRightX = getPerspectiveX(player.y, canvas.width);
  if(player.x - basePlayerW/2 < pLeftX) player.x = pLeftX + basePlayerW/2;
  if(player.x + basePlayerW/2 > pRightX) player.x = pRightX - basePlayerW/2;

  // 子彈更新
  bullets.forEach(b => {
    b.progress += 0.02;
    b.x = (1-b.progress)*b.startX + b.progress*vanishPoint.x;
    b.y = (1-b.progress)*b.startY + b.progress*vanishPoint.y;
  });
  bullets = bullets.filter(b => b.progress < 1);

  enemyBullets.forEach(b => {
    b.progress += 0.02;
    let slope = (b.startX - vanishPoint.x) / (b.startY - vanishPoint.y);
    let targetX = vanishPoint.x + slope * (bottomBoundaryY - vanishPoint.y);
    let targetY = bottomBoundaryY;
    b.x = (1-b.progress)*b.startX + b.progress*targetX;
    b.y = (1-b.progress)*b.startY + b.progress*targetY;
  });
  enemyBullets = enemyBullets.filter(b => b.progress < 1);

  // 敵人移動（修正邊界判斷）
  let leftX = getPerspectiveX(enemy.y, 0);
  let rightX = getPerspectiveX(enemy.y, canvas.width);
  let enemyWidth = rightX - leftX;

  let pLeftX2 = getPerspectiveX(player.y, 0);
  let pRightX2 = getPerspectiveX(player.y, canvas.width);
  let playerWidth = pRightX2 - pLeftX2;

  let enemyScale = enemyWidth / playerWidth;
  let enemyW = basePlayerW * enemyScale;
  let enemySpeed = playerMaxSpeed * (enemyWidth / playerWidth);

  enemy.x += enemy.dir * enemySpeed;
  if(enemy.x - enemyW/2 <= leftX){ enemy.x = leftX + enemyW/2; enemy.dir = 1; }
  if(enemy.x + enemyW/2 >= rightX){ enemy.x = rightX - enemyW/2; enemy.dir = -1; }

  // 判斷擊中
  bullets.forEach(b => {
    let dx = b.x - enemy.x;
    let dy = b.y - enemy.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    let hitbox = 20 * enemyScale;
    if(dist < hitbox){
      enemyHP--; b.progress = 1;
    }
  });
  enemyBullets.forEach(b => {
    let dx = b.x - player.x;
    let dy = b.y - player.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < 20){
      playerHP--; b.progress = 1;
    }
  });

  if(playerHP <= 0 || enemyHP <= 0){ gameOver = true; restartBtn.style.display = "block"; }
}

// 繪製血條
function drawHP(x, y, hp, maxHP, color){
  ctx.fillStyle = "gray";
  ctx.fillRect(x, y, 100, 10);
  ctx.fillStyle = color;
  ctx.fillRect(x, y, 100 * (hp/maxHP), 10);
}

// 繪製格線
function drawGrid() {
  ctx.strokeStyle = "gray";
  for(let i=0;i<30;i++){
    let x = (canvas.width/30)*i;
    ctx.beginPath();
    ctx.moveTo(x, bottomBoundaryY);
    ctx.lineTo(vanishPoint.x, vanishPoint.y);
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.moveTo(0, bottomBoundaryY);
  ctx.lineTo(canvas.width, bottomBoundaryY);
  ctx.stroke();
}

// 繪製畫面
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 背景圖片
  ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

  drawGrid();

  // 血條位置：玩家左下角，敵人右上角
  drawHP(20, bottomBoundaryY+20, playerHP, maxHP, "cyan");
  drawHP(canvas.width-120, 20, enemyHP, maxHP, "red");

  if(gameOver){
    ctx.fillStyle = "yellow";
    ctx.font = "40px Arial";
    ctx.fillText(playerHP <= 0 ? "敵人勝利!" : "玩家勝利!", canvas.width/2-100, canvas.height/2);
    return;
  }

  // 玩家角色
  ctx.drawImage(playerImg, player.x - basePlayerW/2, player.y - basePlayerH, basePlayerW, basePlayerH);

  // 敵人角色 (透視縮放)
  let leftX = getPerspectiveX(enemy.y, 0);
  let rightX = getPerspectiveX(enemy.y, canvas.width);
  let enemyWidth = rightX - leftX;

  let pLeftX = getPerspectiveX(player.y, 0);
  let pRightX = getPerspectiveX(player.y, canvas.width);
  let playerWidth = pRightX - pLeftX;
  let enemyScale = (enemyWidth / playerWidth)*1.2;

  let enemyW = basePlayerW * enemyScale;
  let enemyH = basePlayerH * enemyScale;
  ctx.drawImage(enemyImg, enemy.x - enemyW/2, enemy.y - enemyH, enemyW, enemyH);

  // 玩家子彈 (透視縮小)
  ctx.fillStyle = "yellow";
  bullets.forEach(b => {
    let pLeftX = getPerspectiveX(b.y, 0);
    let pRightX = getPerspectiveX(b.y, canvas.width);
    let bulletWidth = pRightX - pLeftX;
    let scale = bulletWidth / playerWidth;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 8*scale, 0, Math.PI*2);
    ctx.fill();
  });

  // 敵人子彈 (透視放大)
  ctx.fillStyle = "orange";
  enemyBullets.forEach(b => {
    let eLeftX = getPerspectiveX(b.y, 0);
    let eRightX = getPerspectiveX(b.y, canvas.width);
    let bulletWidth = eRightX - eLeftX;
    let scale = bulletWidth / playerWidth;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 8*scale, 0, Math.PI*2);
    ctx.fill();
  });
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}
gameLoop();

// 重新開始按鈕邏輯
restartBtn.addEventListener("click", () => {
  initGame();
});
</script>
</body>
</html>
