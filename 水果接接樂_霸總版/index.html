<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>è²¡å¯¶æ¥æ¥æ¨‚ - é—œå¡ç‰ˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000;
      font-family: sans-serif; display: flex; justify-content: center; align-items: center;
    }
    #gameWrapper { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 500px; }
    #topBar { width: 100%; display: flex; justify-content: space-between; align-items: center; padding: 8px; }
    #score { font-size: 18px; font-weight: bold; color: #fff; }
    #pauseBtn, #restartBtn { font-size: 16px; padding: 6px 12px; }
    #restartBtn { display: none; }
    #gameCanvas { width: 100%; aspect-ratio: 5 / 6; border: 2px solid #333; background: #000; }
  </style>
</head>
<body>
  <div id="gameWrapper">
    <div id="topBar">
      <div id="score">åˆ†æ•¸: 0</div>
      <button id="pauseBtn">æš«åœ</button>
      <button id="restartBtn">é‡æ–°é–‹å§‹</button>
    </div>
    <canvas id="gameCanvas" width="500" height="600"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const scoreDisplay = document.getElementById("score");
    const restartBtn = document.getElementById("restartBtn");
    const pauseBtn = document.getElementById("pauseBtn");

    const bgImg = new Image(); bgImg.src = "è—¥å±€.png";
    const playerImg = new Image(); playerImg.src = "è§’è‰².png";
    const failImg = new Image(); failImg.src = "å¤±æ•—.png";
    const successImg = new Image(); successImg.src = "æˆåŠŸ.png";
    const bgm = new Audio("BGM.m4a"); bgm.loop = true; bgm.volume = 0.5;

    // ğŸµ éŸ³æ•ˆï¼šeat ä½¿ç”¨éŸ³æ•ˆæ± ï¼Œå…¶é¤˜å–®ä¸€ç‰©ä»¶
    const eatSoundPool = [];
    const eatPoolSize = 5;
    for (let i = 0; i < eatPoolSize; i++) {
      eatSoundPool.push(new Audio("åƒæ°´æœ.m4a"));
    }
    const hitSound = new Audio("è¥¿ç“œç ¸åˆ°.m4a");
    const clearSound = new Audio("é€šé—œ.m4a");

    function playEat(volume = 1) {
      let audio = eatSoundPool.find(a => a.paused || a.ended);
      if (!audio) {
        audio = eatSoundPool[0];
        audio.pause();
        audio.currentTime = 0;
      }
      audio.volume = volume;
      audio.play().catch(err => console.warn("eat æ’­æ”¾å¤±æ•—:", err));
    }

    function playHit(volume = 1) {
      hitSound.volume = volume;
      hitSound.currentTime = 0;
      hitSound.play().catch(err => console.warn("hit æ’­æ”¾å¤±æ•—:", err));
    }

    function playClear(volume = 1) {
      clearSound.volume = volume;
      clearSound.currentTime = 0;
      clearSound.play().catch(err => console.warn("clear æ’­æ”¾å¤±æ•—:", err));
    }

    // ğŸ”“ è§£é–éŸ³æ•ˆï¼ˆè¡Œå‹•ç€è¦½å™¨éœ€è¦äº’å‹•æ‰èƒ½æ’­æ”¾ï¼‰
   function unlockAudio(){
      // åªå‘¼å« load()ï¼Œè®“ç€è¦½å™¨å»ºç«‹æ’­æ”¾ç®¡é“ï¼Œä¸æœƒçœŸçš„å‡ºè²
      bgm.load();
      eatSoundPool.forEach(a => a.load());
      hitSound.load();
      clearSound.load();
    }


    // âš ï¸ ç§»é™¤åŸæœ¬çš„ body click/touch ç¶å®šï¼Œæ”¹æˆæŒ‰ä¸‹ã€Œç¹¼çºŒã€æ™‚æ‰è§¸ç™¼
    let audioUnlocked = false;

    let failRatio = 1;
    failImg.onload = () => { failRatio = failImg.width / failImg.height; };
    let successRatio = 1;
    successImg.onload = () => { successRatio = successImg.width / successImg.height; };

    const fruitImgs = {
      "ğŸ": { img: new Image(), score: 1 },
      "ğŸŒ": { img: new Image(), score: 2 },
      "ğŸŠ": { img: new Image(), score: 3 },
      "ğŸ“": { img: new Image(), score: 5 },
      "ğŸ‰": { img: new Image(), bad: true }
    };
    fruitImgs["ğŸ"].img.src = "apple.png";
    fruitImgs["ğŸŒ"].img.src = "banana.png";
    fruitImgs["ğŸŠ"].img.src = "orange.png";
    fruitImgs["ğŸ“"].img.src = "strawberry.png";
    fruitImgs["ğŸ‰"].img.src = "watermelon.png";

    const fruits = ["ğŸ","ğŸŒ","ğŸŠ","ğŸ“"];
    let player, items, score, gameOver, mouseX, spawnInterval;
    let level, fruitCount, speedMultiplier, watermelonChance;
    let paused = true;
    let catchRadius = 34;
    const maxLevel = 10;
    const fruitsPerLevel = 30;

    let floatingTexts = [];
    let facingRight = true;
    let showSuccess = false;
    let successTimer = 0;
    let confetti = [];

    function initGame() {
      player = {
        x: canvas.width/2 - 60,
        y: canvas.height - canvas.height/4 - 20,
        width: canvas.height/4 * 0.75,
        height: canvas.height/4,
        fail: false
      };
      items = [];
      score = 0;
      gameOver = false;
      level = 1;
      fruitCount = 0;
      speedMultiplier = 1;
      watermelonChance = 0.2;
      scoreDisplay.textContent = "åˆ†æ•¸: 0 | ç¬¬ 1 é—œ | å‰©é¤˜è²¡å¯¶: " + fruitsPerLevel;

      restartBtn.style.display = "none";
      pauseBtn.style.display = "inline-block";
      mouseX = player.x;

      clearInterval(spawnInterval);
      spawnInterval = setInterval(spawnItem, 1000);

      paused = true;
      pauseBtn.textContent = "ç¹¼çºŒ"; // åˆå§‹é¡¯ç¤ºã€Œç¹¼çºŒã€
      bgm.pause(); bgm.currentTime = 0;

      update();
    }

    function getCanvasCoords(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);
      return {x,y};
    }

    canvas.addEventListener("mousemove", e=>{
      const pos = getCanvasCoords(e.clientX, e.clientY);
      mouseX = pos.x - player.width/2;
    });

    canvas.addEventListener("touchmove", e=>{
      const touch = e.touches[0];
      const pos = getCanvasCoords(touch.clientX, touch.clientY);
      mouseX = pos.x - player.width/2;
    });

    pauseBtn.addEventListener("click", ()=>{
      if(gameOver) return;
      paused = !paused;
      if(!paused) {
        // ç¬¬ä¸€æ¬¡ç¹¼çºŒæ™‚è§£é–éŸ³æ•ˆ
        if(!audioUnlocked){
          unlockAudio();
          audioUnlocked = true;
        }
        update();
        pauseBtn.textContent = "æš«åœ";
        bgm.play();
      } else {
        pauseBtn.textContent = "ç¹¼çºŒ";
        bgm.pause();
      }
    });

    function spawnItem(){
      if(gameOver||paused) return;
      if(fruitCount>=fruitsPerLevel) return;
      const isBad=Math.random()<watermelonChance;
      const fruitKey=isBad?"ğŸ‰":fruits[Math.floor(Math.random()*fruits.length)];
      if(!isBad) fruitCount++;
      items.push({x:Math.random()*(canvas.width-60),y:-60,key:fruitKey,bad:isBad});
      scoreDisplay.textContent="åˆ†æ•¸: "+score+" | ç¬¬ "+level+" é—œ | å‰©é¤˜è²¡å¯¶: " + (fruitsPerLevel - fruitCount);
    }



    function update(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(bgImg,0,0,canvas.width,canvas.height);
      ctx.fillStyle="rgba(0,0,0,0.4)"; ctx.fillRect(0,0,canvas.width,canvas.height);

      player.x+=(mouseX-player.x)*0.1;
      facingRight = mouseX > player.x;

      ctx.save();
      ctx.translate(player.x+player.width/2, player.y);
      if(facingRight){ ctx.scale(-1,1); }
      if(player.fail){
        const targetHeight = player.height * 4/5;
        const targetWidth = targetHeight * failRatio;
        const offsetY = player.height - targetHeight;
        const offsetX = (player.width - targetWidth) / 2;
        ctx.drawImage(failImg,-player.width/2+offsetX,offsetY,targetWidth,targetHeight);
      } else {
                ctx.drawImage(playerImg,-player.width/2,0,player.width,player.height);
      }
      ctx.restore();

      if(gameOver){
        ctx.fillStyle="#fff"; ctx.font="28px sans-serif"; ctx.textAlign="center";
        ctx.fillText("éŠæˆ²çµæŸ! æœ€çµ‚åˆ†æ•¸: "+score,canvas.width/2,canvas.height/2-20);
        ctx.fillText("ç¥æ‚¨ç™¼å¤§è²¡, ä¸‰èŠè—¥å¸«è—¥å±€é—œå¿ƒæ‚¨",canvas.width/2,canvas.height/2+20);
        return;
      }

      if(paused){
        if(showSuccess && successTimer > 0){
          const targetHeight = canvas.height * 0.75; 
          const targetWidth = targetHeight * successRatio; 
          const centerX = canvas.width / 2; 
          const offsetX = centerX - targetWidth / 2; 
          const offsetY = canvas.height - targetHeight; 
          ctx.drawImage(successImg, offsetX, offsetY, targetWidth, targetHeight);

          confetti.forEach(c=>{
            ctx.fillStyle = c.color;
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.size, 0, Math.PI*2);
            ctx.fill();
            c.y += c.speed;
            c.x += Math.sin(c.y/20)*2;
          });
          confetti = confetti.filter(c => c.y < canvas.height+20);

          successTimer--;
          if(successTimer <= 0){
            showSuccess = false;
          }
          requestAnimationFrame(update);
          return;
        }

        ctx.fillStyle="rgba(0,0,0,0.7)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle="#fff"; ctx.font="20px sans-serif"; ctx.textAlign="center";
        ctx.fillText("éŠæˆ²æš«åœ",canvas.width/2,canvas.height/2-60);
        ctx.fillText("è¦å‰‡ï¼š",canvas.width/2,canvas.height/2-30);
        ctx.fillText("æ¯é—œæ‰è½ 30 å€‹è²¡å¯¶",canvas.width/2,canvas.height/2);
        ctx.fillText("æ¼æ¥è²¡å¯¶æœƒæ‰£åˆ†ï¼Œæœ€ä½ 0 åˆ†",canvas.width/2,canvas.height/2+30);
        ctx.fillText("æ¥åˆ°è²¡å¯¶é¡¯ç¤ºåŠ åˆ†æ–‡å­—",canvas.width/2,canvas.height/2+60);
        ctx.fillText("é»æ“Šæš«åœæŒ‰éˆ•ç¹¼çºŒéŠæˆ²",canvas.width/2,canvas.height/2+90);
        return;
      }

      // æ°´æœæ›´æ–°èˆ‡ç¢°æ’æª¢æ¸¬
      items.forEach(item=>{
        item.y+=Math.min(10*speedMultiplier,(4+score*0.05)*speedMultiplier);
        const fruitData=fruitImgs[item.key];
		
		let drawW = 60;
        let drawH = 60;
        if(item.bad){ // bad=true â†’ è¥¿ç“œ
         drawW *= 1.3;
         drawH *= 1.3;
        }
        ctx.drawImage(fruitData.img, item.x, item.y, drawW, drawH);


        const playerCenterX=player.x+player.width/2;
        const playerCenterY=player.y+player.height/2;
        const fruitCenterX=item.x+30;
        const fruitCenterY=item.y+30;
        const dx=playerCenterX-fruitCenterX, dy=playerCenterY-fruitCenterY;
        const distance=Math.sqrt(dx*dx+dy*dy);

        if(distance<catchRadius){
          if(item.bad){ 
            playHit();
            endGame(); 
          } else {
            score+=fruitData.score;
            playEat(0.8);
            showFloatingText("+"+fruitData.score,"lime",fruitCenterX,fruitCenterY);
            scoreDisplay.textContent="åˆ†æ•¸: "+score+" | ç¬¬ "+level+" é—œ | å‰©é¤˜è²¡å¯¶: " + (fruitsPerLevel - fruitCount);
          }
          items = items.filter(f => f !== item);
        }
      });

      // æ¼æ¥æ°´æœ â†’ æ‰£åˆ†
      items.forEach(item=>{ 
        if(!item.bad && item.y > canvas.height){ 
          let deduct = fruitImgs[item.key].score; 
          if(score - deduct < 0){ deduct = score; }
          score -= deduct; 
          showFloatingText("-"+deduct,"red",item.x+30,canvas.height-30); 
          scoreDisplay.textContent = "åˆ†æ•¸: " + score + " | ç¬¬ " + level + " é—œ | å‰©é¤˜è²¡å¯¶: " + (fruitsPerLevel - fruitCount);
          items = items.filter(f => f !== item);
        } 
      });

      items = items.filter(item => item.y < canvas.height + 50);

      // åˆ¤æ–·éé—œ
      if(fruitCount >= fruitsPerLevel && items.length === 0){
        if(level < maxLevel){
          level++;
          fruitCount = 0;
          speedMultiplier *= 1.1;
          watermelonChance *= 1.1;
          scoreDisplay.textContent = 
            "åˆ†æ•¸: " + score + " | ç¬¬ " + level + " é—œ | å‰©é¤˜è²¡å¯¶: " + fruitsPerLevel;
          paused = true;
          pauseBtn.textContent = "ç¹¼çºŒ";
          bgm.pause();

          playClear();

          showSuccess = true;
          successTimer = 180; 
          confetti = [];
          for(let i=0;i<50;i++){
            confetti.push({
              x: Math.random()*canvas.width,
              y: Math.random()*-canvas.height/2,
              size: 5+Math.random()*5,
              speed: 2+Math.random()*3,
              color: `hsl(${Math.random()*360},100%,50%)`
            });
          }
        } else {
          endGame();
        }
      }

      // é¡¯ç¤ºæµ®å‹•åˆ†æ•¸æ–‡å­—
      floatingTexts.forEach(ft=>{
        ctx.globalAlpha = ft.alpha;
        ctx.fillStyle = ft.color;
        ctx.font = "30px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.globalAlpha = 1.0;

        ft.y -= 1;
        ft.alpha -= 0.03;
      });
      floatingTexts = floatingTexts.filter(ft => ft.alpha > 0);

      requestAnimationFrame(update);
    }
    function showFloatingText(text,color,x,y){
      floatingTexts.push({ text, color, x, y, alpha:1 });
    }

    function endGame(){
      gameOver = true;
      player.fail = true;
      restartBtn.style.display = "block";
      pauseBtn.style.display = "none";
      bgm.pause();
    }
	
    restartBtn.addEventListener("click", initGame);
    initGame();
  </script>
</body>
</html>